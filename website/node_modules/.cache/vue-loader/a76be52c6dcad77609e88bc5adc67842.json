{"remainingRequest":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ianwow/development/aws-content-analysis/source/website/src/components/TextDetection.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ianwow/development/aws-content-analysis/source/website/src/components/TextDetection.vue","mtime":1642006298168},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1633407346687},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/thread-loader/dist/cjs.js","mtime":1633407346686},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/babel-loader/lib/index.js","mtime":1633407348173},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1633407346687},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js","mtime":1633407348650}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBMb2FkaW5nIGZyb20gJ0AvY29tcG9uZW50cy9Mb2FkaW5nLnZ1ZScKaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tICd2dWV4JwovLyBUT0RPOiBUaGluayBhYm91dCBob3cgdG8gaGFuZGxlICJMSU5FIiBkZXRlY3Rpb24gdHlwZXMsIG1heWJlIGFub3RoZXIgY29tcG9uZW50PyBvciBhIGRyb3AgZG93biB0byBmaWx0ZXIgd29yZHMgLyBsaW5lcwpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogIlRleHREZXRlY3Rpb24iLAogIGNvbXBvbmVudHM6IHsKICAgIExvYWRpbmcKICB9LAogIHByb3BzOiB7CiAgICBtZWRpYVR5cGU6IHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICBkZWZhdWx0OiAiIgogICAgfSwKICB9LAogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBjdXJsQ29tbWFuZDogJycsCiAgICAgIHNlYXJjaFF1ZXJ5OiAnJywKICAgICAgc2hvd0VsYXN0aWNzZWFyY2hBcGlSZXF1ZXN0OiBmYWxzZSwKICAgICAgQ29uZmlkZW5jZTogOTAsCiAgICAgIGhpZ2hfY29uZmlkZW5jZV9kYXRhOiBbXSwKICAgICAgZWxhc3RpY3NlYXJjaF9kYXRhOiBbXSwKICAgICAgYm94ZXNfYXZhaWxhYmxlOiBbXSwKICAgICAgY291bnRfZGlzdGluY3Rfd29yZHM6IDAsCiAgICAgIGNvdW50X3dvcmRzOiAwLAogICAgICAvL2NvdW50X2Rpc3RpbmN0X2xpbmVzOiAwLAogICAgICAvL2NvdW50X2xpbmVzOiAwLAogICAgICBpc0J1c3k6IGZhbHNlLAogICAgICBvcGVyYXRvcjogJ3RleHREZXRlY3Rpb24nLAogICAgICBjYW52YXNSZWZyZXNoSW50ZXJ2YWw6IHVuZGVmaW5lZCwKICAgICAgdGltZXNlcmllczogbmV3IE1hcCgpLAogICAgICBzZWxlY3RlZFdvcmQ6ICcnLAogICAgICBsb3dlckNvbmZpZGVuY2U6IGZhbHNlLAogICAgICBsb3dlckNvbmZpZGVuY2VNZXNzYWdlOiAnVHJ5IGxvd2VyaW5nIGNvbmZpZGVuY2UgdGhyZXNob2xkJywKICAgIH0KICB9LAogIGNvbXB1dGVkOiB7CiAgICAuLi5tYXBTdGF0ZShbJ3BsYXllciddKSwKICAgIHNvcnRlZF91bmlxdWVfd29yZF9kZXRlY3Rpb25zKCkgewogICAgICAvLyBUaGlzIGZ1bmN0aW9uIHNvcnRzIGFuZCBjb3VudHMgdW5pcXVlIHdvcmRzIGZvciBtb3VzZSBvdmVyIGV2ZW50cyBvbiBidXR0b25zCiAgICAgIGNvbnN0IGVzX2RhdGEgPSB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YTsKICAgICAgY29uc29sZS5sb2coZXNfZGF0YSkKICAgICAgY29uc3QgdW5pcXVlX3dvcmRzID0gbmV3IE1hcCgpOwogICAgICAvL2NvbnN0IHVuaXF1ZV9saW5lcyA9IG5ldyBNYXAoKTsKICAgICAgLy8gc29ydCBhbmQgY291bnQgdW5pcXVlIHdvcmRzIGZvciBtb3VzZSBvdmVyIGV2ZW50cwogICAgICBlc19kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkgewogICAgICAgIGlmIChyZWNvcmQuVHlwZSA9PSAnV09SRCcpIHsKICAgICAgICAgIHVuaXF1ZV93b3Jkcy5zZXQocmVjb3JkLkRldGVjdGVkVGV4dCwgdW5pcXVlX3dvcmRzLmdldChyZWNvcmQuRGV0ZWN0ZWRUZXh0KSA/IHVuaXF1ZV93b3Jkcy5nZXQocmVjb3JkLkRldGVjdGVkVGV4dCkgKyAxIDogMSk7CiAgICAgICAgfQogICAgICAgIC8vIGlmIChyZWNvcmQuVGV4dFR5cGUgPT0gJ0xJTkUnKSB7CiAgICAgICAgLy8gICB1bmlxdWVfbGluZXMuc2V0KHJlY29yZC5EZXRlY3RlZFRleHQsIHVuaXF1ZV9saW5lcy5nZXQocmVjb3JkLkRldGVjdGVkVGV4dCkgPyB1bmlxdWVfbGluZXMuZ2V0KHJlY29yZC5EZXRlY3RlZFRleHQpICsgMSA6IDEpOwogICAgICAgIC8vIH0KICAgICAgICBpZiAocmVjb3JkLkJvdW5kaW5nQm94KSB7CiAgICAgICAgICAvLyBTYXZlIHRoaXMgd29yZCBkZXRlY3Rpb24gdG8gYSBsaXN0IG9mIHdvcmRzIHRoYXQgaGF2ZSBib3VuZGluZyBib3hlcwogICAgICAgICAgdGhpcy5zYXZlQm94ZWREZXRlY3RlZFRleHQocmVjb3JkLkRldGVjdGVkVGV4dCkKICAgICAgICB9CiAgICAgIH0uYmluZCh0aGlzKSk7CiAgICAgIGNvbnN0IHNvcnRlZF91bmlxdWVfd29yZHMgPSBuZXcgTWFwKFsuLi51bmlxdWVfd29yZHMuZW50cmllcygpXS5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKSk7CiAgICAgIC8vY29uc3Qgc29ydGVkX3VuaXF1ZV9saW5lcyA9IG5ldyBNYXAoWy4uLnVuaXF1ZV9saW5lcy5lbnRyaWVzKCldLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pKTsKICAgICAgLy8gSWYgRWxhc3RpY3NlYXJjaCByZXR1cm5lZCB1bmRlZmluZWQgd29yZHMgdGhlbiBkZWxldGUgdGhlbToKICAgICAgc29ydGVkX3VuaXF1ZV93b3Jkcy5kZWxldGUodW5kZWZpbmVkKTsKICAgICAgLy9zb3J0ZWRfdW5pcXVlX2xpbmVzLmRlbGV0ZSh1bmRlZmluZWQpOwogICAgICB0aGlzLmNvdW50RGV0ZWN0ZWRXb3Jkcyhzb3J0ZWRfdW5pcXVlX3dvcmRzLnNpemUsIGVzX2RhdGEubGVuZ3RoKTsKICAgICAgLy90aGlzLmNvdW50RGV0ZWN0ZWRMaW5lcyhzb3J0ZWRfdW5pcXVlX2xpbmVzLnNpemUsIGVzX2RhdGEubGVuZ3RoKTsKICAgICAgY29uc29sZS5sb2coc29ydGVkX3VuaXF1ZV93b3JkcykKICAgICAgcmV0dXJuIHNvcnRlZF91bmlxdWVfd29yZHMKICAgIH0sCiAgfSwKICB3YXRjaDogewogICAgLy8gVGhlc2Ugd2F0Y2hlcyB1cGRhdGUgdGhlIGxpbmUgY2hhcnQKICAgIHNlbGVjdGVkV29yZDogZnVuY3Rpb24oKSB7CiAgICAgIHRoaXMuY2hhcnREYXRhKCk7CiAgICB9LAogICAgZWxhc3RpY3NlYXJjaF9kYXRhOiBmdW5jdGlvbigpIHsKICAgICAgdGhpcy5jaGFydERhdGEoKTsKICAgIH0sCiAgfSwKICBkZWFjdGl2YXRlZDogZnVuY3Rpb24gKCkgewogICAgdGhpcy5ib3hlc19hdmFpbGFibGUgPSBbXTsKICAgIHRoaXMuc2VsZWN0ZWRXb3JkID0gJyc7CiAgICBjbGVhckludGVydmFsKHRoaXMuY2FudmFzUmVmcmVzaEludGVydmFsKTsKICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTsKICAgIGxldCBjdHg7CiAgICBpZiAoY2FudmFzKSBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgIGlmIChjdHgpIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsKICB9LAogIGFjdGl2YXRlZDogZnVuY3Rpb24gKCkgewogICAgdGhpcy5mZXRjaEFzc2V0RGF0YSgpOwogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24oKSB7CiAgICB0aGlzLmdldEN1cmxDb21tYW5kKCk7CiAgfSwKICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiAoKSB7CiAgICB0aGlzLmhpZ2hfY29uZmlkZW5jZV9kYXRhID0gW107CiAgICB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YSA9IFtdOwogICAgdGhpcy5jb3VudF9kaXN0aW5jdF93b3JkcyA9IDA7CiAgICB0aGlzLmNvdW50X3dvcmRzID0gMDsKICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jYW52YXNSZWZyZXNoSW50ZXJ2YWwpOwogIH0sCiAgbWV0aG9kczogewogICAgZ2V0Q3VybENvbW1hbmQoKSB7CiAgICAgIHRoaXMuc2VhcmNoUXVlcnkgPSAnQXNzZXRJZDonK3RoaXMuJHJvdXRlLnBhcmFtcy5hc3NldF9pZCsnIENvbmZpZGVuY2U6PicrdGhpcy5Db25maWRlbmNlKycgT3BlcmF0b3I6Jyt0aGlzLm9wZXJhdG9yOwogICAgICAvLyBnZXQgY3VybCBjb21tYW5kIHRvIHNlYXJjaCBlbGFzdGljc2VhcmNoCiAgICAgIHRoaXMuY3VybENvbW1hbmQgPSAnYXdzY3VybCAtWCBHRVQgLS1wcm9maWxlIGRlZmF1bHQgLS1zZXJ2aWNlIGVzIC0tcmVnaW9uICcgKyB0aGlzLkFXU19SRUdJT04gKyAnIFwnJyArIHRoaXMuU0VBUkNIX0VORFBPSU5UICsgJy9fc2VhcmNoP3E9JyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnNlYXJjaFF1ZXJ5KSArICdcJycKICAgIH0sCiAgICBzYXZlQm94ZWREZXRlY3RlZFRleHQoZGV0ZWN0ZWRUZXh0KXsKICAgICAgaWYgKCF0aGlzLmJveGVzX2F2YWlsYWJsZS5pbmNsdWRlcyhkZXRlY3RlZFRleHQpKSB7CiAgICAgICAgdGhpcy5ib3hlc19hdmFpbGFibGUucHVzaChkZXRlY3RlZFRleHQpOwogICAgICB9CiAgICB9LAogICAgY291bnREZXRlY3RlZFdvcmRzKHVuaXF1ZVdvcmRDb3VudCwgdG90YWxXb3JkQ291bnQpIHsKICAgICAgdGhpcy5jb3VudF9kaXN0aW5jdF93b3JkcyA9IHVuaXF1ZVdvcmRDb3VudDsKICAgICAgdGhpcy5jb3VudF93b3JkcyA9IHRvdGFsV29yZENvdW50OwogICAgICAvLyB0aGlzLmNvdW50X2Rpc3RpbmN0X2xpbmVzID0gdW5pcXVlTGluZUNvdW50OwogICAgICAvLyB0aGlzLmNvdW50X2xpbmVzID0gdG90YWxMaW5lQ291bnQ7CiAgICB9LAogICAgc2F2ZUZpbGUoKSB7CiAgICAgIGNvbnN0IGVsYXN0aWNzZWFyY2hfZGF0YSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhKTsKICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtlbGFzdGljc2VhcmNoX2RhdGFdLCB7dHlwZTogJ3RleHQvcGxhaW4nfSk7CiAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKSwKICAgICAgICBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpOwogICAgICBhLmRvd25sb2FkID0gImRhdGEuanNvbiI7CiAgICAgIGEuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpOwogICAgICBhLmRhdGFzZXQuZG93bmxvYWR1cmwgPSBbJ3RleHQvanNvbicsIGEuZG93bmxvYWQsIGEuaHJlZl0uam9pbignOicpOwogICAgICBlLmluaXRFdmVudCgnY2xpY2snLCB0cnVlLCBmYWxzZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7CiAgICAgIGEuZGlzcGF0Y2hFdmVudChlKTsKICAgIH0sCiAgICB1cGRhdGVDb25maWRlbmNlIChldmVudCkgewogICAgICB0aGlzLmlzQnVzeSA9IHRydWU7CiAgICAgIHRoaXMuQ29uZmlkZW5jZSA9IGV2ZW50LnRhcmdldC52YWx1ZTsKICAgICAgaWYgKHRoaXMubWVkaWFUeXBlID09PSAidmlkZW8iKSB7CiAgICAgICAgLy8gcmVkcmF3IG1hcmtlcnMgb24gdmlkZW8gdGltZWxpbmUKICAgICAgICB0aGlzLnBsYXllci5tYXJrZXJzLnJlbW92ZUFsbCgpOwogICAgICB9CiAgICAgIHRoaXMuZ2V0Q3VybENvbW1hbmQoKTsKICAgICAgdGhpcy5mZXRjaEFzc2V0RGF0YSgpOwogICAgfSwKICAgIC8vIHVwZGF0ZU1hcmtlcnMgdXBkYXRlcyBtYXJrZXJzIGluIHRoZSB2aWRlbyBwbGF5ZXIgYW5kIGlzIGNhbGxlZCB3aGVuIHNvbWVvbmUgY2xpY2tzIG9uIGEgd29yZCBidXR0b24KICAgIHVwZGF0ZU1hcmtlcnMgKHdvcmQpIHsKICAgICAgLy8gY2xlYXIgY2FudmFzIGZvciByZWRyYXdpbmcKICAgICAgdGhpcy5ib3hlc19hdmFpbGFibGUgPSBbXTsKICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbnZhc1JlZnJlc2hJbnRlcnZhbCk7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTsKICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7CiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsKICAgICAgY3R4LnN0cm9rZVN0eWxlID0gInJlZCI7CiAgICAgIGN0eC5mb250ID0gIjE1cHggQXJpYWwiOwogICAgICBjdHgudGV4dEFsaWduID0gImNlbnRlciI7CiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAibWlkZGxlIjsKICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZWQiOwogICAgICBpZiAodGhpcy5zZWxlY3RlZFdvcmQgPT09IHdvcmQpIHsKICAgICAgICAvLyBrZWVwIHRoZSBjYW52YXMgY2xlYXIgY2FudmFzIGlmIHVzZXIgY2xpY2tlZCB0aGUgd29yZCBidXR0b24gYSBzZWNvbmQgY29uc2VjdXRpdmUgdGltZQogICAgICAgIHRoaXMuc2VsZWN0ZWRXb3JkID0gIiI7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgICAgdGhpcy5zZWxlY3RlZFdvcmQgPSB3b3JkOyAgICAgICAgLy8gaW5pdGlhbGl6ZSBsaXN0cyBvZiBib3hlcyBhbmQgbWFya2VycyB0byBiZSBkcmF3bgogICAgICBjb25zdCBib3hNYXAgPSBuZXcgTWFwKCk7CiAgICAgIGNvbnN0IG1hcmtlcnMgPSBbXTsKICAgICAgY29uc3QgZXNfZGF0YSA9IHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhOwogICAgICBlc19kYXRhLmZvckVhY2goIGZ1bmN0aW9uKHJlY29yZCkgewogICAgICAgIGlmIChyZWNvcmQuRGV0ZWN0ZWRUZXh0ID09PSB3b3JkKSB7CiAgICAgICAgICAvLyBTYXZlIHdvcmQgdGV4dCBvdmVybGF5aW5nIG9uIHZpZGVvIHRpbWVsaW5lCiAgICAgICAgICBtYXJrZXJzLnB1c2goeyd0aW1lJzogcmVjb3JkLlRpbWVzdGFtcC8xMDAwLCAndGV4dCc6IHJlY29yZC5EZXRlY3RlZFRleHQsICdvdmVybGF5VGV4dCc6IHJlY29yZC5EZXRlY3RlZFRleHR9KTsKICAgICAgICAgIC8vIFNhdmUgYm91bmRpbmcgYm94IGluZm8gaWYgaXQgZXhpc3RzCiAgICAgICAgICBpZiAocmVjb3JkLkJvdW5kaW5nQm94KSB7CiAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHJlY29yZDsKICAgICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIGltYWdlIHByb2Nlc3NpbmcgdG8gYSBzZXBhcmF0ZSBjb21wb25lbnQKICAgICAgICAgICAgICBpZiAodGhpcy5tZWRpYVR5cGUgPT09ICJpbWFnZSIpIHsKICAgICAgICAgICAgICAgIC8vIHVzZSB0aW1lc3RhbXAgdG8gaW5kZXggYm94ZXMgaW4gdGhlIGJveE1hcCBjb2xsZWN0aW9uCiAgICAgICAgICAgICAgICBjb25zdCBib3hpbmZvID0gewogICAgICAgICAgICAgICAgICAnbmFtZSc6IGl0ZW0uRGV0ZWN0ZWRUZXh0LAogICAgICAgICAgICAgICAgICAnY29uZmlkZW5jZSc6IChpdGVtLkNvbmZpZGVuY2UgKiAxKS50b0ZpeGVkKDIpLAogICAgICAgICAgICAgICAgICAneCc6IGl0ZW0uQm91bmRpbmdCb3guTGVmdCAqIGNhbnZhcy53aWR0aCwKICAgICAgICAgICAgICAgICAgJ3knOiBpdGVtLkJvdW5kaW5nQm94LlRvcCAqIGNhbnZhcy5oZWlnaHQsCiAgICAgICAgICAgICAgICAgICd3aWR0aCc6IGl0ZW0uQm91bmRpbmdCb3guV2lkdGggKiBjYW52YXMud2lkdGgsCiAgICAgICAgICAgICAgICAgICdoZWlnaHQnOiBpdGVtLkJvdW5kaW5nQm94LkhlaWdodCAqIGNhbnZhcy5oZWlnaHQKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICBib3hNYXAuc2V0KGksIFtib3hpbmZvXSkKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgLy8gVXNlIHRpbWUgcmVzb2x1dGlvbiBvZiAwLjEgc2Vjb25kCiAgICAgICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLnJvdW5kKHJlY29yZC5UaW1lc3RhbXAvMTAwKTsKICAgICAgICAgICAgICAgIGNvbnN0IGJveGluZm8gPSB7J3RpbWVzdGFtcCc6TWF0aC5jZWlsKHJlY29yZC5UaW1lc3RhbXAvMTAwKSwgJ25hbWUnOnJlY29yZC5EZXRlY3RlZFRleHQsICdjb25maWRlbmNlJzoocmVjb3JkLkNvbmZpZGVuY2UgKiAxKS50b0ZpeGVkKDIpLCAneCc6aXRlbS5Cb3VuZGluZ0JveC5MZWZ0KmNhbnZhcy53aWR0aCwgJ3knOml0ZW0uQm91bmRpbmdCb3guVG9wKmNhbnZhcy5oZWlnaHQsICd3aWR0aCc6aXRlbS5Cb3VuZGluZ0JveC5XaWR0aCpjYW52YXMud2lkdGgsICdoZWlnaHQnOml0ZW0uQm91bmRpbmdCb3guSGVpZ2h0KmNhbnZhcy5oZWlnaHR9OwogICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGJvdW5kaW5nIGJveGVzIGZvciB0aGlzIGluc3RhbmNlIGF0IHRoaXMKICAgICAgICAgICAgICAgIC8vIHRpbWVzdGFtcCwgdGhlbiBzYXZlIHRoZW0gdG9nZXRoZXIgaW4gYW4gYXJyYXkuCiAgICAgICAgICAgICAgICBpZiAoYm94TWFwLmhhcyh0aW1lc3RhbXApKSB7CiAgICAgICAgICAgICAgICAgIGJveE1hcC5nZXQodGltZXN0YW1wKS5wdXNoKGJveGluZm8pCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBib3hNYXAuc2V0KHRpbWVzdGFtcCwgW2JveGluZm9dKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0uYmluZCh0aGlzKSk7CiAgICAgIGlmIChib3hNYXAuc2l6ZSA+IDApIHsKICAgICAgICB0aGlzLmRyYXdCb3hlcyhib3hNYXApOwogICAgICB9CiAgICAgIC8vIFRPRE86IG1vdmUgaW1hZ2UgcHJvY2Vzc2luZyB0byBhIHNlcGFyYXRlIGNvbXBvbmVudAogICAgICBpZiAodGhpcy5tZWRpYVR5cGUgPT09ICJ2aWRlbyIpIHsKICAgICAgICAvLyByZWRyYXcgbWFya2VycyBvbiB2aWRlbyB0aW1lbGluZQogICAgICAgIHRoaXMucGxheWVyLm1hcmtlcnMucmVtb3ZlQWxsKCk7CiAgICAgICAgdGhpcy5wbGF5ZXIubWFya2Vycy5hZGQobWFya2Vycyk7CiAgICAgIH0KICAgIH0sCiAgICBhc3luYyBmZXRjaEFzc2V0RGF0YSAoKSB7CiAgICAgICAgbGV0IGFwaU5hbWUgPSAnY29udGVudEFuYWx5c2lzRWxhc3RpY3NlYXJjaCc7CiAgICAgICAgbGV0IHBhdGggPSAnL19zZWFyY2gnOwogICAgICAgIGxldCBhcGlQYXJhbXMgPSB7CiAgICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30sCiAgICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnM6IHsncSc6IHRoaXMuc2VhcmNoUXVlcnksICdkZWZhdWx0X29wZXJhdG9yJzogJ0FORCcsICdzaXplJzogMTAwMDB9CiAgICAgICAgfTsKICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiRBbXBsaWZ5LkFQSS5nZXQoYXBpTmFtZSwgcGF0aCwgYXBpUGFyYW1zKTsKICAgICAgICBpZiAoIXJlc3BvbnNlKSB7CiAgICAgICAgICB0aGlzLnNob3dFbGFzdGljU2VhcmNoQWxlcnQgPSB0cnVlCiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgbGV0IGVzX2RhdGEgPSBbXTsKICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCByZXNwb25zZTsKICAgICAgICAgIGxldCBkYXRhID0gcmVzdWx0LmhpdHMuaGl0czsKICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCAmJiB0aGlzLkNvbmZpZGVuY2UgPiA1NSkgewogICAgICAgICAgICAgIHRoaXMubG93ZXJDb25maWRlbmNlID0gdHJ1ZTsKICAgICAgICAgICAgICB0aGlzLmxvd2VyQ29uZmlkZW5jZU1lc3NhZ2UgPSAnVHJ5IGxvd2VyaW5nIGNvbmZpZGVuY2UgdGhyZXNob2xkJwogICAgICAgICAgfQogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHRoaXMubG93ZXJDb25maWRlbmNlID0gZmFsc2U7CiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICAgICAgZXNfZGF0YS5wdXNoKGRhdGFbaV0uX3NvdXJjZSkKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgdGhpcy5lbGFzdGljc2VhcmNoX2RhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVzX2RhdGEpKTsKICAgICAgICAgIHRoaXMuaXNCdXN5ID0gZmFsc2UKICAgICAgfQogICAgfSwKICAgIGRyYXdCb3hlczogZnVuY3Rpb24oYm94TWFwKSB7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTsKICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7CiAgICAgIC8vIFRPRE86IG1vdmUgaW1hZ2UgcHJvY2Vzc2luZyB0byBhIHNlcGFyYXRlIGNvbXBvbmVudAogICAgICBpZiAodGhpcy5tZWRpYVR5cGUgPT09ICJpbWFnZSIpIHsKICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7CiAgICAgICAgY3R4LmJlZ2luUGF0aCgpOwogICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICJyZWQiOwogICAgICAgIGN0eC5mb250ID0gIjE1cHggQXJpYWwiOwogICAgICAgIGN0eC50ZXh0QWxpZ24gPSAiY2VudGVyIjsKICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gIm1pZGRsZSI7CiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZWQiOwogICAgICAgIC8vIEZvciBlYWNoIGJveCBpbnN0YW5jZS4uLgogICAgICAgIGJveE1hcC5mb3JFYWNoKCBpID0+IHsKICAgICAgICAgIGNvbnN0IGRyYXdNZSA9IGlbMF07CiAgICAgICAgICBpZiAoZHJhd01lKSB7CiAgICAgICAgICAgIGN0eC5yZWN0KGRyYXdNZS54LCBkcmF3TWUueSwgZHJhd01lLndpZHRoLCBkcmF3TWUuaGVpZ2h0KTsKICAgICAgICAgICAgLy8gRHJhdyBvYmplY3QgbmFtZSBhbmQgY29uZmlkZW5jZSBzY29yZQogICAgICAgICAgICBjdHguZmlsbFRleHQoZHJhd01lLm5hbWUgKyAiICgiICsgZHJhd01lLmNvbmZpZGVuY2UgKyAiJSkiLCAoZHJhd01lLnggKyBkcmF3TWUud2lkdGggLyAyKSwgZHJhd01lLnkgLSAxMCk7CiAgICAgICAgICAgIGN0eC5zdHJva2UoKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICAvLyBub3cgcmV0dXJuIHNvIHdlIGF2b2lkIHJlbmRlcmluZyBhbnkgb2YgdGhlIHZpZGVvIHJlbGF0ZWQgY29tcG9uZW50cyBiZWxvdwogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIC8vIElmIHVzZXIganVzdCBjbGlja2VkIGEgbmV3IHdvcmQuLi4KICAgICAgaWYgKHRoaXMuY2FudmFzUmVmcmVzaEludGVydmFsICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAvLyAuLi50aGVuIHJlc2V0IHRoZSBvbGQgY2FudmFzIHJlZnJlc2ggaW50ZXJ2YWwuCiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbnZhc1JlZnJlc2hJbnRlcnZhbCkKICAgICAgfQogICAgICAvLyBMb29rIGZvciBhbmQgZHJhdyBib3VuZGluZyBib3hlcyBldmVyeSAxMDBtcwogICAgICBjb25zdCBpbnRlcnZhbF9tcyA9IDEwMDsKICAgICAgY29uc3QgZXJhc2Vfb25faXRlcmF0aW9uID0gMjsKICAgICAgbGV0IGkgPSAwOwogICAgICB0aGlzLmNhbnZhc1JlZnJlc2hJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsKICAgICAgICBpKys7CiAgICAgICAgLy8gZXJhc2Ugb2xkIGJvdW5kaW5nIGJveGVzCiAgICAgICAgaWYgKCF0aGlzLnBsYXllci5wYXVzZWQoKSAmJiBpICUgZXJhc2Vfb25faXRlcmF0aW9uID09PSAwKSB7CiAgICAgICAgICBpPTA7CiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7CiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAicmVkIjsKICAgICAgICAgIGN0eC5mb250ID0gIjE1cHggQXJpYWwiOwogICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICJjZW50ZXIiOwogICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICJtaWRkbGUiOwogICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZWQiOwogICAgICAgIH0KICAgICAgICAvLyBHZXQgY3VycmVudCBwbGF5ZXIgdGltZXN0YW1wIHRvIHRoZSBuZWFyZXN0IDEvMTB0aCBzZWNvbmQKICAgICAgICBjb25zdCBwbGF5ZXJfdGltZXN0YW1wID0gTWF0aC5yb3VuZCh0aGlzLnBsYXllci5jdXJyZW50VGltZSgpKjEwLjApOwogICAgICAgIC8vIElmIHdlIGhhdmUgYSBib3ggZm9yIHRoZSBwbGF5ZXIncyB0aW1lc3RhbXAuLi4KICAgICAgICBpZiAoYm94TWFwLmhhcyhwbGF5ZXJfdGltZXN0YW1wKSkgewogICAgICAgICAgaT0wOwogICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpOwogICAgICAgICAgY3R4LmJlZ2luUGF0aCgpOwogICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gInJlZCI7CiAgICAgICAgICBjdHguZm9udCA9ICIxNXB4IEFyaWFsIjsKICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAiY2VudGVyIjsKICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAibWlkZGxlIjsKICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAicmVkIjsKICAgICAgICAgIC8vIC4uLnRoZW4gZ2V0IGEgbGlzdCBvZiBib3ggaW5zdGFuY2VzCiAgICAgICAgICBjb25zdCBpbnN0YW5jZV9saXN0ID0gKGJveE1hcC5nZXQocGxheWVyX3RpbWVzdGFtcCkpLm1hcCggaXRlbSA9PiBpdGVtLmluc3RhbmNlKS5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSk7CiAgICAgICAgICAvLyBGb3IgZWFjaCBib3ggaW5zdGFuY2UuLi4KICAgICAgICAgIGluc3RhbmNlX2xpc3QuZm9yRWFjaCggaSA9PiB7CiAgICAgICAgICAgIC8vIC4uLmdldCBhbGwgb2YgdGhlIGJveGVzIGJlbG9uZ2luZyB0byB0aGlzIGluc3RhbmNlCiAgICAgICAgICAgIC8vIGF0IHRoZSBjdXJyZW50IHRpbWVzdGFtcC4KICAgICAgICAgICAgY29uc3QgYm94ZXMgPSBib3hNYXAuZ2V0KHBsYXllcl90aW1lc3RhbXApLmZpbHRlcihib3ggPT4gYm94Lmluc3RhbmNlID09PSBpKTsKICAgICAgICAgICAgYm94ZXMuZm9yRWFjaCAoZHJhd01lID0+IHsKICAgICAgICAgICAgICBpZiAoZHJhd01lKSB7CiAgICAgICAgICAgICAgICBjdHgucmVjdChkcmF3TWUueCwgZHJhd01lLnksIGRyYXdNZS53aWR0aCwgZHJhd01lLmhlaWdodCk7CiAgICAgICAgICAgICAgICAvLyBEcmF3IG9iamVjdCBuYW1lIGFuZCBjb25maWRlbmNlIHNjb3JlCiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoZHJhd01lLm5hbWUgKyAiICgiICsgZHJhd01lLmNvbmZpZGVuY2UgKyAiJSkiLCAoZHJhd01lLnggKyBkcmF3TWUud2lkdGggLyAyKSwgZHJhd01lLnkgLSAxMCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KQogICAgICAgICAgfSk7CiAgICAgICAgICBjdHguc3Ryb2tlKCk7CiAgICAgICAgfQogICAgICB9LmJpbmQodGhpcyksIGludGVydmFsX21zKTsKICAgIH0sCiAgICBjaGFydERhdGEoKSB7CiAgICAgIGxldCB0aW1lc2VyaWVzID0gbmV3IE1hcCgpOwogICAgICBmdW5jdGlvbiBzYXZlVGltZXN0YW1wIChtaWxsaXNlY29uZCkgewogICAgICAgIGlmICh0aW1lc2VyaWVzLmhhcyhtaWxsaXNlY29uZCkpIHsKICAgICAgICAgIHRpbWVzZXJpZXMuc2V0KG1pbGxpc2Vjb25kLCB7IngiOiBtaWxsaXNlY29uZCwgInkiOiB0aW1lc2VyaWVzLmdldChtaWxsaXNlY29uZCkueSArIDF9KQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aW1lc2VyaWVzLnNldChtaWxsaXNlY29uZCwgeyJ4IjogbWlsbGlzZWNvbmQsICJ5IjoxfSkKICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3QgZXNfZGF0YSA9IHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhOwogICAgICBlc19kYXRhLmZvckVhY2goIGZ1bmN0aW9uKHJlY29yZCkgewogICAgICAgIC8vIERlZmluZSB0aW1lc3RhbXAgd2l0aCBtaWxsaXNlY29uZCByZXNvbHV0aW9uCiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBNYXRoLnJvdW5kKHJlY29yZC5UaW1lc3RhbXApOwogICAgICAgIGlmICh0aGlzLnNlbGVjdGVkV29yZCkgewogICAgICAgICAgLy8gSWYgd29yZCBpcyBkZWZpbmVkLCB0aGVuIGVudW1lcmF0ZSB0aW1lc3RhbXBzIGZvciB0aGF0IHdvcmQKICAgICAgICAgIGlmIChyZWNvcmQuRGV0ZWN0ZWRUZXh0ID09PSB0aGlzLnNlbGVjdGVkV29yZCkgewogICAgICAgICAgICAgICAgc2F2ZVRpbWVzdGFtcChtaWxsaXNlY29uZCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgLy8gTm8gd29yZCBoYXMgYmVlbiBzZWxlY3RlZCwgc28gZW51bWVyYXRlIHRpbWVzdGFtcHMgZm9yIGFsbCB3b3JkIG5hbWVzLgogICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGJvdW5kaW5nIGJveGVzIGlmIHByZXNlbnQuCiAgICAgICAgICBzYXZlVGltZXN0YW1wKG1pbGxpc2Vjb25kKTsKICAgICAgICB9CiAgICAgIH0uYmluZCh0aGlzKSk7CiAgICAgIC8vc29ydCB0aGUgdGltZXNlcmllcyBtYXAgYnkgaXRzIG1pbGxpc2Vjb25kIGtleQogICAgICBjb25zdCBvcmRlcmVkX3RpbWVzZXJpZXMgPSBuZXcgTWFwKFsuLi50aW1lc2VyaWVzLmVudHJpZXMoKV0uc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSkpOwogICAgICBjb25zdCBjaGFydFR1cGxlcyA9IEFycmF5LmZyb20ob3JkZXJlZF90aW1lc2VyaWVzLnZhbHVlcygpKTsKICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCd1cGRhdGVUaW1lc2VyaWVzJywgY2hhcnRUdXBsZXMpOwogICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3VwZGF0ZVNlbGVjdGVkTGFiZWwnLCB0aGlzLnNlbGVjdGVkV29yZCk7CiAgICB9LAogIH0KfQo="},{"version":3,"sources":["TextDetection.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"TextDetection.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <b-container fluid>\n    <b-col>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          Confidence Threshold<br>\n          <input\n            type=\"range\"\n            value=\"90\"\n            min=\"55\"\n            max=\"99\"\n            step=\"1\"\n            @click=\"updateConfidence\"\n          >\n          {{ Confidence }}%<br>\n        </div>\n      </b-row>\n      <div v-if=\"lowerConfidence === true\">\n        {{ lowerConfidenceMessage }}\n      </div>\n      <div\n        v-if=\"isBusy\"\n        class=\"wrapper\"\n      >\n        <Loading />\n      </div>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          <br>\n          <template v-for=\"detectedWords in sorted_unique_word_detections\">\n            <template v-if=\"boxes_available.includes(detectedWords[0])\">\n              <!-- Show darker button outline if bounding boxes are available for the detected text -->\n              <b-button\n                v-b-tooltip.hover\n                variant=\"outline-dark\"\n                :title=\"detectedWords[1]\"\n                size=\"sm\"\n                pill\n                @click=\"updateMarkers(detectedWords[0])\"\n              >\n                {{ detectedWords[0]+\"*\" }}\n              </b-button> &nbsp;\n            </template>\n            <template v-else>\n              <b-button\n                v-b-tooltip.hover\n                variant=\"outline-secondary\"\n                :title=\"detectedWords[1]\"\n                size=\"sm\"\n                pill\n                @click=\"updateMarkers(detectedWords[0])\"\n              >\n                {{ detectedWords[0] }}\n              </b-button> &nbsp;\n            </template>\n          </template>\n        </div>\n      </b-row>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div\n          v-if=\"isBusy === false\"\n          class=\"wrapper\"\n        >\n          <p class=\"text-muted\">\n            ({{ count_words }} identified text objects, {{ count_distinct_words }} unique)\n          </p>\n          <hr>\n          <p class=\"text-muted\">\n            * Indicates bounding boxes are available.\n          </p>\n        </div>\n      </b-row>\n    </b-col>\n    <b-button\n      type=\"button\"\n      @click=\"saveFile()\"\n    >\n      Download Data\n    </b-button>\n    <br>\n    <b-button\n        :pressed=\"false\"\n        size=\"sm\"\n        variant=\"link\"\n        class=\"text-decoration-none\"\n        @click=\"showElasticsearchApiRequest = true\"\n    >\n      Show API request to get these results\n    </b-button>\n    <b-modal\n        v-model=\"showElasticsearchApiRequest\"\n        scrollable\n        title=\"SEARCH API\"\n        ok-only\n    >\n      <label>Request URL:</label>\n      <pre v-highlightjs><code class=\"bash\">GET {{ SEARCH_ENDPOINT }}workflow/execution</code></pre>\n      <label>Search query:</label>\n      <pre v-highlightjs=\"JSON.stringify(searchQuery)\"><code class=\"json\"></code></pre>\n      <label>Sample command:</label>\n      <pre v-highlightjs=\"curlCommand\"><code class=\"bash\"></code></pre>\n    </b-modal>\n  </b-container>\n</template>\n\n<script>\n  import Loading from '@/components/Loading.vue'\n  import { mapState } from 'vuex'\n  // TODO: Think about how to handle \"LINE\" detection types, maybe another component? or a drop down to filter words / lines\n  export default {\n    name: \"TextDetection\",\n    components: {\n      Loading\n    },\n    props: {\n      mediaType: {\n        type: String,\n        default: \"\"\n      },\n    },\n    data() {\n      return {\n        curlCommand: '',\n        searchQuery: '',\n        showElasticsearchApiRequest: false,\n        Confidence: 90,\n        high_confidence_data: [],\n        elasticsearch_data: [],\n        boxes_available: [],\n        count_distinct_words: 0,\n        count_words: 0,\n        //count_distinct_lines: 0,\n        //count_lines: 0,\n        isBusy: false,\n        operator: 'textDetection',\n        canvasRefreshInterval: undefined,\n        timeseries: new Map(),\n        selectedWord: '',\n        lowerConfidence: false,\n        lowerConfidenceMessage: 'Try lowering confidence threshold',\n      }\n    },\n    computed: {\n      ...mapState(['player']),\n      sorted_unique_word_detections() {\n        // This function sorts and counts unique words for mouse over events on buttons\n        const es_data = this.elasticsearch_data;\n        console.log(es_data)\n        const unique_words = new Map();\n        //const unique_lines = new Map();\n        // sort and count unique words for mouse over events\n        es_data.forEach(function (record) {\n          if (record.Type == 'WORD') {\n            unique_words.set(record.DetectedText, unique_words.get(record.DetectedText) ? unique_words.get(record.DetectedText) + 1 : 1);\n          }\n          // if (record.TextType == 'LINE') {\n          //   unique_lines.set(record.DetectedText, unique_lines.get(record.DetectedText) ? unique_lines.get(record.DetectedText) + 1 : 1);\n          // }\n          if (record.BoundingBox) {\n            // Save this word detection to a list of words that have bounding boxes\n            this.saveBoxedDetectedText(record.DetectedText)\n          }\n        }.bind(this));\n        const sorted_unique_words = new Map([...unique_words.entries()].slice().sort((a, b) => b[1] - a[1]));\n        //const sorted_unique_lines = new Map([...unique_lines.entries()].slice().sort((a, b) => b[1] - a[1]));\n        // If Elasticsearch returned undefined words then delete them:\n        sorted_unique_words.delete(undefined);\n        //sorted_unique_lines.delete(undefined);\n        this.countDetectedWords(sorted_unique_words.size, es_data.length);\n        //this.countDetectedLines(sorted_unique_lines.size, es_data.length);\n        console.log(sorted_unique_words)\n        return sorted_unique_words\n      },\n    },\n    watch: {\n      // These watches update the line chart\n      selectedWord: function() {\n        this.chartData();\n      },\n      elasticsearch_data: function() {\n        this.chartData();\n      },\n    },\n    deactivated: function () {\n      this.boxes_available = [];\n      this.selectedWord = '';\n      clearInterval(this.canvasRefreshInterval);\n      const canvas = document.getElementById('canvas');\n      let ctx;\n      if (canvas) ctx = canvas.getContext('2d');\n      if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);\n    },\n    activated: function () {\n      this.fetchAssetData();\n    },\n    mounted: function() {\n      this.getCurlCommand();\n    },\n    beforeDestroy: function () {\n      this.high_confidence_data = [];\n      this.elasticsearch_data = [];\n      this.count_distinct_words = 0;\n      this.count_words = 0;\n      clearInterval(this.canvasRefreshInterval);\n    },\n    methods: {\n      getCurlCommand() {\n        this.searchQuery = 'AssetId:'+this.$route.params.asset_id+' Confidence:>'+this.Confidence+' Operator:'+this.operator;\n        // get curl command to search elasticsearch\n        this.curlCommand = 'awscurl -X GET --profile default --service es --region ' + this.AWS_REGION + ' \\'' + this.SEARCH_ENDPOINT + '/_search?q=' + encodeURIComponent(this.searchQuery) + '\\''\n      },\n      saveBoxedDetectedText(detectedText){\n        if (!this.boxes_available.includes(detectedText)) {\n          this.boxes_available.push(detectedText);\n        }\n      },\n      countDetectedWords(uniqueWordCount, totalWordCount) {\n        this.count_distinct_words = uniqueWordCount;\n        this.count_words = totalWordCount;\n        // this.count_distinct_lines = uniqueLineCount;\n        // this.count_lines = totalLineCount;\n      },\n      saveFile() {\n        const elasticsearch_data = JSON.stringify(this.elasticsearch_data);\n        const blob = new Blob([elasticsearch_data], {type: 'text/plain'});\n        const e = document.createEvent('MouseEvents'),\n          a = document.createElement('a');\n        a.download = \"data.json\";\n        a.href = window.URL.createObjectURL(blob);\n        a.dataset.downloadurl = ['text/json', a.download, a.href].join(':');\n        e.initEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n        a.dispatchEvent(e);\n      },\n      updateConfidence (event) {\n        this.isBusy = true;\n        this.Confidence = event.target.value;\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n        }\n        this.getCurlCommand();\n        this.fetchAssetData();\n      },\n      // updateMarkers updates markers in the video player and is called when someone clicks on a word button\n      updateMarkers (word) {\n        // clear canvas for redrawing\n        this.boxes_available = [];\n        clearInterval(this.canvasRefreshInterval);\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.strokeStyle = \"red\";\n        ctx.font = \"15px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillStyle = \"red\";\n        if (this.selectedWord === word) {\n          // keep the canvas clear canvas if user clicked the word button a second consecutive time\n          this.selectedWord = \"\";\n          return\n        }\n        this.selectedWord = word;        // initialize lists of boxes and markers to be drawn\n        const boxMap = new Map();\n        const markers = [];\n        const es_data = this.elasticsearch_data;\n        es_data.forEach( function(record) {\n          if (record.DetectedText === word) {\n            // Save word text overlaying on video timeline\n            markers.push({'time': record.Timestamp/1000, 'text': record.DetectedText, 'overlayText': record.DetectedText});\n            // Save bounding box info if it exists\n            if (record.BoundingBox) {\n                const item = record;\n                // TODO: move image processing to a separate component\n                if (this.mediaType === \"image\") {\n                  // use timestamp to index boxes in the boxMap collection\n                  const boxinfo = {\n                    'name': item.DetectedText,\n                    'confidence': (item.Confidence * 1).toFixed(2),\n                    'x': item.BoundingBox.Left * canvas.width,\n                    'y': item.BoundingBox.Top * canvas.height,\n                    'width': item.BoundingBox.Width * canvas.width,\n                    'height': item.BoundingBox.Height * canvas.height\n                  };\n                  boxMap.set(i, [boxinfo])\n                } else {\n                  // Use time resolution of 0.1 second\n                  const timestamp = Math.round(record.Timestamp/100);\n                  const boxinfo = {'timestamp':Math.ceil(record.Timestamp/100), 'name':record.DetectedText, 'confidence':(record.Confidence * 1).toFixed(2), 'x':item.BoundingBox.Left*canvas.width, 'y':item.BoundingBox.Top*canvas.height, 'width':item.BoundingBox.Width*canvas.width, 'height':item.BoundingBox.Height*canvas.height};\n                  // If there are multiple bounding boxes for this instance at this\n                  // timestamp, then save them together in an array.\n                  if (boxMap.has(timestamp)) {\n                    boxMap.get(timestamp).push(boxinfo)\n                  } else {\n                    boxMap.set(timestamp, [boxinfo])\n                  }\n                }\n            }\n          }\n        }.bind(this));\n        if (boxMap.size > 0) {\n          this.drawBoxes(boxMap);\n        }\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n          this.player.markers.add(markers);\n        }\n      },\n      async fetchAssetData () {\n          let apiName = 'contentAnalysisElasticsearch';\n          let path = '/_search';\n          let apiParams = {\n            headers: {'Content-Type': 'application/json'},\n            queryStringParameters: {'q': this.searchQuery, 'default_operator': 'AND', 'size': 10000}\n          };\n          let response = await this.$Amplify.API.get(apiName, path, apiParams);\n          if (!response) {\n            this.showElasticSearchAlert = true\n          }\n          else {\n            let es_data = [];\n            let result = await response;\n            let data = result.hits.hits;\n            if (data.length === 0 && this.Confidence > 55) {\n                this.lowerConfidence = true;\n                this.lowerConfidenceMessage = 'Try lowering confidence threshold'\n            }\n            else {\n              this.lowerConfidence = false;\n              for (let i = 0, len = data.length; i < len; i++) {\n                es_data.push(data[i]._source)\n              }\n            }\n            this.elasticsearch_data = JSON.parse(JSON.stringify(es_data));\n            this.isBusy = false\n        }\n      },\n      drawBoxes: function(boxMap) {\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"image\") {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.strokeStyle = \"red\";\n          ctx.font = \"15px Arial\";\n          ctx.textAlign = \"center\";\n          ctx.textBaseline = \"middle\";\n          ctx.fillStyle = \"red\";\n          // For each box instance...\n          boxMap.forEach( i => {\n            const drawMe = i[0];\n            if (drawMe) {\n              ctx.rect(drawMe.x, drawMe.y, drawMe.width, drawMe.height);\n              // Draw object name and confidence score\n              ctx.fillText(drawMe.name + \" (\" + drawMe.confidence + \"%)\", (drawMe.x + drawMe.width / 2), drawMe.y - 10);\n              ctx.stroke();\n            }\n          });\n          // now return so we avoid rendering any of the video related components below\n          return\n        }\n        // If user just clicked a new word...\n        if (this.canvasRefreshInterval !== undefined) {\n          // ...then reset the old canvas refresh interval.\n          clearInterval(this.canvasRefreshInterval)\n        }\n        // Look for and draw bounding boxes every 100ms\n        const interval_ms = 100;\n        const erase_on_iteration = 2;\n        let i = 0;\n        this.canvasRefreshInterval = setInterval(function () {\n          i++;\n          // erase old bounding boxes\n          if (!this.player.paused() && i % erase_on_iteration === 0) {\n            i=0;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.beginPath();\n            ctx.strokeStyle = \"red\";\n            ctx.font = \"15px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = \"red\";\n          }\n          // Get current player timestamp to the nearest 1/10th second\n          const player_timestamp = Math.round(this.player.currentTime()*10.0);\n          // If we have a box for the player's timestamp...\n          if (boxMap.has(player_timestamp)) {\n            i=0;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.beginPath();\n            ctx.strokeStyle = \"red\";\n            ctx.font = \"15px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = \"red\";\n            // ...then get a list of box instances\n            const instance_list = (boxMap.get(player_timestamp)).map( item => item.instance).filter((v, i, a) => a.indexOf(v) === i);\n            // For each box instance...\n            instance_list.forEach( i => {\n              // ...get all of the boxes belonging to this instance\n              // at the current timestamp.\n              const boxes = boxMap.get(player_timestamp).filter(box => box.instance === i);\n              boxes.forEach (drawMe => {\n                if (drawMe) {\n                  ctx.rect(drawMe.x, drawMe.y, drawMe.width, drawMe.height);\n                  // Draw object name and confidence score\n                  ctx.fillText(drawMe.name + \" (\" + drawMe.confidence + \"%)\", (drawMe.x + drawMe.width / 2), drawMe.y - 10);\n                }\n              })\n            });\n            ctx.stroke();\n          }\n        }.bind(this), interval_ms);\n      },\n      chartData() {\n        let timeseries = new Map();\n        function saveTimestamp (millisecond) {\n          if (timeseries.has(millisecond)) {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\": timeseries.get(millisecond).y + 1})\n          } else {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\":1})\n          }\n        }\n        const es_data = this.elasticsearch_data;\n        es_data.forEach( function(record) {\n          // Define timestamp with millisecond resolution\n          const millisecond = Math.round(record.Timestamp);\n          if (this.selectedWord) {\n            // If word is defined, then enumerate timestamps for that word\n            if (record.DetectedText === this.selectedWord) {\n                  saveTimestamp(millisecond);\n            }\n          }\n          else {\n            // No word has been selected, so enumerate timestamps for all word names.\n            // Iterate through bounding boxes if present.\n            saveTimestamp(millisecond);\n          }\n        }.bind(this));\n        //sort the timeseries map by its millisecond key\n        const ordered_timeseries = new Map([...timeseries.entries()].slice().sort((a, b) => a[0] - b[0]));\n        const chartTuples = Array.from(ordered_timeseries.values());\n        this.$store.commit('updateTimeseries', chartTuples);\n        this.$store.commit('updateSelectedLabel', this.selectedWord);\n      },\n    }\n  }\n</script>\n"]}]}