{"remainingRequest":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ianwow/development/aws-content-analysis/source/website/src/components/ContentModeration.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ianwow/development/aws-content-analysis/source/website/src/components/ContentModeration.vue","mtime":1638395687233},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1633407346687},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/thread-loader/dist/cjs.js","mtime":1633407346686},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/babel-loader/lib/index.js","mtime":1633407348173},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1633407346687},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js","mtime":1633407348650}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7IG1hcFN0YXRlIH0gZnJvbSAndnVleCcKaW1wb3J0IExvYWRpbmcgZnJvbSAnQC9jb21wb25lbnRzL0xvYWRpbmcudnVlJwoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICJDb250ZW50TW9kZXJhdGlvbiIsCiAgY29tcG9uZW50czogewogICAgTG9hZGluZwogIH0sCiAgcHJvcHM6IHsKICAgIG1lZGlhVHlwZTogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICIiCiAgICB9LAogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIENvbmZpZGVuY2U6IDkwLAogICAgICBoaWdoX2NvbmZpZGVuY2VfZGF0YTogW10sCiAgICAgIGVsYXN0aWNzZWFyY2hfZGF0YTogW10sCiAgICAgIGNvdW50X2Rpc3RpbmN0X2xhYmVsczogMCwKICAgICAgY291bnRfbGFiZWxzOiAwLAogICAgICBpc0J1c3k6IGZhbHNlLAogICAgICBvcGVyYXRvcjogJ2NvbnRlbnRfbW9kZXJhdGlvbicsCiAgICAgIHRpbWVzZXJpZXM6IG5ldyBNYXAoKSwKICAgICAgc2VsZWN0ZWRMYWJlbDogJycsCiAgICAgIGxvd2VyQ29uZmlkZW5jZTogZmFsc2UsCiAgICAgIGxvd2VyQ29uZmlkZW5jZU1lc3NhZ2U6ICdUcnkgbG93ZXJpbmcgY29uZmlkZW5jZSB0aHJlc2hvbGQnCiAgICB9CiAgfSwKICBjb21wdXRlZDogewogICAgLi4ubWFwU3RhdGUoWydwbGF5ZXInXSksCiAgICBzb3J0ZWRfdW5pcXVlX2xhYmVscygpIHsKICAgICAgLy8gVGhpcyBmdW5jdGlvbiBzb3J0cyBhbmQgY291bnRzIHVuaXF1ZSBsYWJlbHMgZm9yIG1vdXNlIG92ZXIgZXZlbnRzIG9uIGxhYmVsIGJ1dHRvbnMKICAgICAgY29uc3QgZXNfZGF0YSA9IHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhOwogICAgICBjb25zdCB1bmlxdWVfbGFiZWxzID0gbmV3IE1hcCgpOwogICAgICAvLyBzb3J0IGFuZCBjb3VudCB1bmlxdWUgbGFiZWxzIGZvciBsYWJlbCBtb3VzZSBvdmVyIGV2ZW50cwogICAgICBlc19kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkgewogICAgICAgIHVuaXF1ZV9sYWJlbHMuc2V0KHJlY29yZC5OYW1lLCB1bmlxdWVfbGFiZWxzLmdldChyZWNvcmQuTmFtZSkgPyB1bmlxdWVfbGFiZWxzLmdldChyZWNvcmQuTmFtZSkgKyAxIDogMSkKICAgICAgfSk7CiAgICAgIGNvbnN0IHNvcnRlZF91bmlxdWVfbGFiZWxzID0gbmV3IE1hcChbLi4udW5pcXVlX2xhYmVscy5lbnRyaWVzKCldLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pKTsKICAgICAgLy8gSWYgRWxhc3RpY3NlYXJjaCByZXR1cm5lZCB1bmRlZmluZWQgbGFiZWxzIHRoZW4gZGVsZXRlIHRoZW06CiAgICAgIHNvcnRlZF91bmlxdWVfbGFiZWxzLmRlbGV0ZSh1bmRlZmluZWQpOwogICAgICB0aGlzLmNvdW50TGFiZWxzKHNvcnRlZF91bmlxdWVfbGFiZWxzLnNpemUsIGVzX2RhdGEubGVuZ3RoKTsKICAgICAgcmV0dXJuIHNvcnRlZF91bmlxdWVfbGFiZWxzCiAgICB9CiAgfSwKICB3YXRjaDogewogICAgLy8gVGhlc2Ugd2F0Y2hlcyB1cGRhdGUgdGhlIGxpbmUgY2hhcnQKICAgIHNlbGVjdGVkTGFiZWw6IGZ1bmN0aW9uKCkgewogICAgICB0aGlzLmNoYXJ0RGF0YSgpOwogICAgfSwKICAgIGVsYXN0aWNzZWFyY2hfZGF0YTogZnVuY3Rpb24oKSB7CiAgICAgIHRoaXMuY2hhcnREYXRhKCk7CiAgICB9LAogIH0sCiAgZGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uICgpIHsKICAgIGNvbnNvbGUubG9nKCdkZWFjdGl2YXRlZCBjb21wb25lbnQ6JywgdGhpcy5vcGVyYXRvcik7CiAgICB0aGlzLnNlbGVjdGVkTGFiZWwgPSAnJzsKICB9LAogIGFjdGl2YXRlZDogZnVuY3Rpb24gKCkgewogICAgY29uc29sZS5sb2coJ2FjdGl2YXRlZCBjb21wb25lbnQ6JywgdGhpcy5vcGVyYXRvcik7CiAgICB0aGlzLmZldGNoQXNzZXREYXRhKCk7CiAgfSwKICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiAoKSB7CiAgICB0aGlzLmhpZ2hfY29uZmlkZW5jZV9kYXRhID0gW107CiAgICB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YSA9IFtdOwogICAgdGhpcy5jb3VudF9kaXN0aW5jdF9sYWJlbHMgPSAwOwogICAgdGhpcy5jb3VudF9sYWJlbHMgPSAwOwogIH0sCiAgbWV0aG9kczogewogICAgY291bnRMYWJlbHModW5pcXVlX2NvdW50LCB0b3RhbF9jb3VudCkgewogICAgICB0aGlzLmNvdW50X2Rpc3RpbmN0X2xhYmVscyA9IHVuaXF1ZV9jb3VudDsKICAgICAgdGhpcy5jb3VudF9sYWJlbHMgPSB0b3RhbF9jb3VudDsKICAgIH0sCiAgICBzYXZlRmlsZSgpIHsKICAgICAgY29uc3QgZWxhc3RpY3NlYXJjaF9kYXRhID0gdGhpcy5lbGFzdGljc2VhcmNoX2RhdGE7CiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoZWxhc3RpY3NlYXJjaF9kYXRhKV0sIHt0eXBlOiAndGV4dC9wbGFpbid9KTsKICAgICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpLAogICAgICAgIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7CiAgICAgIGEuZG93bmxvYWQgPSAiZGF0YS5qc29uIjsKICAgICAgYS5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7CiAgICAgIGEuZGF0YXNldC5kb3dubG9hZHVybCA9IFsndGV4dC9qc29uJywgYS5kb3dubG9hZCwgYS5ocmVmXS5qb2luKCc6Jyk7CiAgICAgIGUuaW5pdEV2ZW50KCdjbGljaycsIHRydWUsIGZhbHNlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTsKICAgICAgYS5kaXNwYXRjaEV2ZW50KGUpOwogICAgfSwKICAgIHVwZGF0ZUNvbmZpZGVuY2UgKGV2ZW50KSB7CiAgICAgIHRoaXMuaXNCdXN5ID0gIXRoaXMuaXNCdXN5OwogICAgICB0aGlzLkNvbmZpZGVuY2UgPSBldmVudC50YXJnZXQudmFsdWU7CiAgICAgIC8vIFRPRE86IG1vdmUgaW1hZ2UgcHJvY2Vzc2luZyB0byBhIHNlcGFyYXRlIGNvbXBvbmVudAogICAgICBpZiAodGhpcy5tZWRpYVR5cGUgPT09ICJ2aWRlbyIpIHsKICAgICAgICAvLyByZWRyYXcgbWFya2VycyBvbiB2aWRlbyB0aW1lbGluZQogICAgICAgIHRoaXMucGxheWVyLm1hcmtlcnMucmVtb3ZlQWxsKCk7CiAgICAgIH0KICAgICAgdGhpcy5mZXRjaEFzc2V0RGF0YSgpCiAgICB9LAogICAgLy8gdXBkYXRlTWFya2VycyB1cGRhdGVzIG1hcmtlcnMgaW4gdGhlIHZpZGVvIHBsYXllciBhbmQgaXMgY2FsbGVkIHdoZW4gc29tZW9uZSBjbGlja3Mgb24gYSBsYWJlbCBidXR0b24KICAgIHVwZGF0ZU1hcmtlcnMgKGxhYmVsKSB7CiAgICAgIGlmICh0aGlzLnNlbGVjdGVkTGFiZWwgPT09IGxhYmVsKSB7CiAgICAgICAgLy8ga2VlcCB0aGUgY2FudmFzIGNsZWFyIGNhbnZhcyBpZiB1c2VyIGNsaWNrZWQgdGhlIGxhYmVsIGJ1dHRvbiBhIHNlY29uZCBjb25zZWN1dGl2ZSB0aW1lCiAgICAgICAgdGhpcy5zZWxlY3RlZExhYmVsID0gIiI7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgICAgdGhpcy5zZWxlY3RlZExhYmVsID0gbGFiZWw7CiAgICAgIGxldCBtYXJrZXJzID0gW107CiAgICAgIGNvbnN0IGVzX2RhdGEgPSB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YTsKICAgICAgZXNfZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHsKICAgICAgICBpZiAocmVjb3JkLk5hbWUgPT09IGxhYmVsKSB7CiAgICAgICAgICBtYXJrZXJzLnB1c2goeyd0aW1lJzogcmVjb3JkLlRpbWVzdGFtcC8xMDAwLCAndGV4dCc6IHJlY29yZC5OYW1lLCAnb3ZlcmxheVRleHQnOiByZWNvcmQuTmFtZX0pCiAgICAgICAgfQogICAgICB9KTsKICAgICAgLy8gVE9ETzogbW92ZSBpbWFnZSBwcm9jZXNzaW5nIHRvIGEgc2VwYXJhdGUgY29tcG9uZW50CiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZSA9PT0gInZpZGVvIikgewogICAgICAgIC8vIHJlZHJhdyBtYXJrZXJzIG9uIHZpZGVvIHRpbWVsaW5lCiAgICAgICAgdGhpcy5wbGF5ZXIubWFya2Vycy5yZW1vdmVBbGwoKTsKICAgICAgICB0aGlzLnBsYXllci5tYXJrZXJzLmFkZChtYXJrZXJzKTsKICAgICAgfQogICAgfSwKICAgIGFzeW5jIGZldGNoQXNzZXREYXRhICgpIHsKICAgICAgICBsZXQgcXVlcnkgPSAnQXNzZXRJZDonK3RoaXMuJHJvdXRlLnBhcmFtcy5hc3NldF9pZCsnIENvbmZpZGVuY2U6PicrdGhpcy5Db25maWRlbmNlKycgT3BlcmF0b3I6Jyt0aGlzLm9wZXJhdG9yOwogICAgICAgIGxldCBhcGlOYW1lID0gJ2NvbnRlbnRBbmFseXNpc0VsYXN0aWNzZWFyY2gnOwogICAgICAgIGxldCBwYXRoID0gJy9fc2VhcmNoJzsKICAgICAgICBsZXQgYXBpUGFyYW1zID0gewogICAgICAgICAgaGVhZGVyczogeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbid9LAogICAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzOiB7J3EnOiBxdWVyeSwgJ2RlZmF1bHRfb3BlcmF0b3InOiAnQU5EJywgJ3NpemUnOiAxMDAwMH0KICAgICAgICB9OwogICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuJEFtcGxpZnkuQVBJLmdldChhcGlOYW1lLCBwYXRoLCBhcGlQYXJhbXMpOwogICAgICAgIGlmICghcmVzcG9uc2UpIHsKICAgICAgICAgIHRoaXMuc2hvd0VsYXN0aWNTZWFyY2hBbGVydCA9IHRydWUKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICBsZXQgZXNfZGF0YSA9IFtdOwogICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlOwogICAgICAgICAgbGV0IGRhdGEgPSByZXN1bHQuaGl0cy5oaXRzOwogICAgICAgICAgbGV0IGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDsKICAgICAgICAgIGlmIChkYXRhTGVuZ3RoID09PSAwICYmIHRoaXMuQ29uZmlkZW5jZSA+IDU1KSAgewogICAgICAgICAgICB0aGlzLmxvd2VyQ29uZmlkZW5jZSA9IHRydWU7CiAgICAgICAgICAgIHRoaXMubG93ZXJDb25maWRlbmNlTWVzc2FnZSA9ICdUcnkgbG93ZXJpbmcgY29uZmlkZW5jZSB0aHJlc2hvbGQnCiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgdGhpcy5sb3dlckNvbmZpZGVuY2UgPSBmYWxzZTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRhdGFMZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICAgIGVzX2RhdGEucHVzaChkYXRhW2ldLl9zb3VyY2UpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlc19kYXRhKSk7CiAgICAgICAgICB0aGlzLmlzQnVzeSA9IGZhbHNlCiAgICAgIH0KICAgIH0sCiAgICBjaGFydERhdGEoKSB7CiAgICAgIGxldCB0aW1lc2VyaWVzID0gbmV3IE1hcCgpOwogICAgICBmdW5jdGlvbiBzYXZlVGltZXN0YW1wIChtaWxsaXNlY29uZCkgewogICAgICAgIGlmICh0aW1lc2VyaWVzLmhhcyhtaWxsaXNlY29uZCkpIHsKICAgICAgICAgIHRpbWVzZXJpZXMuc2V0KG1pbGxpc2Vjb25kLCB7IngiOiBtaWxsaXNlY29uZCwgInkiOiB0aW1lc2VyaWVzLmdldChtaWxsaXNlY29uZCkueSArIDF9KQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aW1lc2VyaWVzLnNldChtaWxsaXNlY29uZCwgeyJ4IjogbWlsbGlzZWNvbmQsICJ5IjoxfSkKICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3QgZXNfZGF0YSA9IHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhOwogICAgICBlc19kYXRhLmZvckVhY2goIGZ1bmN0aW9uKHJlY29yZCkgewogICAgICAgIC8vIERlZmluZSB0aW1lc3RhbXAgd2l0aCBtaWxsaXNlY29uZCByZXNvbHV0aW9uCiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmQgPSBNYXRoLnJvdW5kKHJlY29yZC5UaW1lc3RhbXApOwogICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTGFiZWwpIHsKICAgICAgICAgIC8vIElmIGxhYmVsIGlzIGRlZmluZWQsIHRoZW4gZW51bWVyYXRlIHRpbWVzdGFtcHMgZm9yIHRoYXQgbGFiZWwKICAgICAgICAgIGlmIChyZWNvcmQuTmFtZSA9PT0gdGhpcy5zZWxlY3RlZExhYmVsKSB7CiAgICAgICAgICAgIHNhdmVUaW1lc3RhbXAobWlsbGlzZWNvbmQpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBObyBsYWJlbCBoYXMgYmVlbiBzZWxlY3RlZCwgc28gZW51bWVyYXRlIHRpbWVzdGFtcHMgZm9yIGFsbCBsYWJlbCBuYW1lcy4KICAgICAgICAgIHNhdmVUaW1lc3RhbXAobWlsbGlzZWNvbmQpOwogICAgICAgIH0KICAgICAgfS5iaW5kKHRoaXMpKTsKICAgICAgLy9zb3J0IHRoZSB0aW1lc2VyaWVzIG1hcCBieSBpdHMgbWlsbGlzZWNvbmQga2V5CiAgICAgIGNvbnN0IG9yZGVyZWRfdGltZXNlcmllcyA9IG5ldyBNYXAoWy4uLnRpbWVzZXJpZXMuZW50cmllcygpXS5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKSk7CiAgICAgIGNvbnN0IGNoYXJ0VHVwbGVzID0gQXJyYXkuZnJvbShvcmRlcmVkX3RpbWVzZXJpZXMudmFsdWVzKCkpOwogICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3VwZGF0ZVRpbWVzZXJpZXMnLCBjaGFydFR1cGxlcyk7CiAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgndXBkYXRlU2VsZWN0ZWRMYWJlbCcsIHRoaXMuc2VsZWN0ZWRMYWJlbCk7CiAgICB9LAogIH0KfQo="},{"version":3,"sources":["ContentModeration.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2EA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ContentModeration.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <b-container fluid>\n    <b-col>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          Confidence Threshold<br>\n          <input\n            type=\"range\"\n            value=\"90\"\n            min=\"55\"\n            max=\"99\"\n            step=\"1\"\n            @click=\"updateConfidence\"\n          >\n          {{ Confidence }}%<br>\n        </div>\n      </b-row>\n      <div v-if=\"lowerConfidence === true\">\n        {{ lowerConfidenceMessage }}\n      </div>\n      <div\n        v-if=\"isBusy\"\n        class=\"wrapper\"\n      >\n        <Loading />\n      </div>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          <br>\n          <template v-for=\"label in sorted_unique_labels\">\n            <!-- Show lighter button outline since content moderation never provides bounding boxes -->\n            <b-button\n              v-b-tooltip.hover\n              variant=\"outline-secondary\"\n              :title=\"label[1]\"\n              size=\"sm\"\n              pill\n              @click=\"updateMarkers(label[0])\"\n            >\n              {{ label[0] }}\n            </b-button> &nbsp;\n          </template>\n        </div>\n      </b-row>\n\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div\n          v-if=\"isBusy === false\"\n          class=\"wrapper\"\n        >\n          <br><p class=\"text-muted\">\n            ({{ count_labels }} identified objects, {{ count_distinct_labels }} unique)\n          </p>\n        </div>\n      </b-row>\n    </b-col>\n    <b-button\n      type=\"button\"\n      @click=\"saveFile()\"\n    >\n      Download Data\n    </b-button>\n  </b-container>\n</template>\n\n<script>\n  import { mapState } from 'vuex'\n  import Loading from '@/components/Loading.vue'\n\n  export default {\n    name: \"ContentModeration\",\n    components: {\n      Loading\n    },\n    props: {\n      mediaType: {\n        type: String,\n        default: \"\"\n      },\n    },\n    data() {\n      return {\n        Confidence: 90,\n        high_confidence_data: [],\n        elasticsearch_data: [],\n        count_distinct_labels: 0,\n        count_labels: 0,\n        isBusy: false,\n        operator: 'content_moderation',\n        timeseries: new Map(),\n        selectedLabel: '',\n        lowerConfidence: false,\n        lowerConfidenceMessage: 'Try lowering confidence threshold'\n      }\n    },\n    computed: {\n      ...mapState(['player']),\n      sorted_unique_labels() {\n        // This function sorts and counts unique labels for mouse over events on label buttons\n        const es_data = this.elasticsearch_data;\n        const unique_labels = new Map();\n        // sort and count unique labels for label mouse over events\n        es_data.forEach(function (record) {\n          unique_labels.set(record.Name, unique_labels.get(record.Name) ? unique_labels.get(record.Name) + 1 : 1)\n        });\n        const sorted_unique_labels = new Map([...unique_labels.entries()].slice().sort((a, b) => b[1] - a[1]));\n        // If Elasticsearch returned undefined labels then delete them:\n        sorted_unique_labels.delete(undefined);\n        this.countLabels(sorted_unique_labels.size, es_data.length);\n        return sorted_unique_labels\n      }\n    },\n    watch: {\n      // These watches update the line chart\n      selectedLabel: function() {\n        this.chartData();\n      },\n      elasticsearch_data: function() {\n        this.chartData();\n      },\n    },\n    deactivated: function () {\n      console.log('deactivated component:', this.operator);\n      this.selectedLabel = '';\n    },\n    activated: function () {\n      console.log('activated component:', this.operator);\n      this.fetchAssetData();\n    },\n    beforeDestroy: function () {\n      this.high_confidence_data = [];\n      this.elasticsearch_data = [];\n      this.count_distinct_labels = 0;\n      this.count_labels = 0;\n    },\n    methods: {\n      countLabels(unique_count, total_count) {\n        this.count_distinct_labels = unique_count;\n        this.count_labels = total_count;\n      },\n      saveFile() {\n        const elasticsearch_data = this.elasticsearch_data;\n        const blob = new Blob([JSON.stringify(elasticsearch_data)], {type: 'text/plain'});\n        const e = document.createEvent('MouseEvents'),\n          a = document.createElement('a');\n        a.download = \"data.json\";\n        a.href = window.URL.createObjectURL(blob);\n        a.dataset.downloadurl = ['text/json', a.download, a.href].join(':');\n        e.initEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n        a.dispatchEvent(e);\n      },\n      updateConfidence (event) {\n        this.isBusy = !this.isBusy;\n        this.Confidence = event.target.value;\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n        }\n        this.fetchAssetData()\n      },\n      // updateMarkers updates markers in the video player and is called when someone clicks on a label button\n      updateMarkers (label) {\n        if (this.selectedLabel === label) {\n          // keep the canvas clear canvas if user clicked the label button a second consecutive time\n          this.selectedLabel = \"\";\n          return\n        }\n        this.selectedLabel = label;\n        let markers = [];\n        const es_data = this.elasticsearch_data;\n        es_data.forEach(function (record) {\n          if (record.Name === label) {\n            markers.push({'time': record.Timestamp/1000, 'text': record.Name, 'overlayText': record.Name})\n          }\n        });\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n          this.player.markers.add(markers);\n        }\n      },\n      async fetchAssetData () {\n          let query = 'AssetId:'+this.$route.params.asset_id+' Confidence:>'+this.Confidence+' Operator:'+this.operator;\n          let apiName = 'contentAnalysisElasticsearch';\n          let path = '/_search';\n          let apiParams = {\n            headers: {'Content-Type': 'application/json'},\n            queryStringParameters: {'q': query, 'default_operator': 'AND', 'size': 10000}\n          };\n          let response = await this.$Amplify.API.get(apiName, path, apiParams);\n          if (!response) {\n            this.showElasticSearchAlert = true\n          }\n          else {\n            let es_data = [];\n            let result = await response;\n            let data = result.hits.hits;\n            let dataLength = data.length;\n            if (dataLength === 0 && this.Confidence > 55)  {\n              this.lowerConfidence = true;\n              this.lowerConfidenceMessage = 'Try lowering confidence threshold'\n            }\n            else {\n              this.lowerConfidence = false;\n              for (let i = 0, len = dataLength; i < len; i++) {\n                es_data.push(data[i]._source)\n              }\n            }\n            this.elasticsearch_data = JSON.parse(JSON.stringify(es_data));\n            this.isBusy = false\n        }\n      },\n      chartData() {\n        let timeseries = new Map();\n        function saveTimestamp (millisecond) {\n          if (timeseries.has(millisecond)) {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\": timeseries.get(millisecond).y + 1})\n          } else {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\":1})\n          }\n        }\n        const es_data = this.elasticsearch_data;\n        es_data.forEach( function(record) {\n          // Define timestamp with millisecond resolution\n          const millisecond = Math.round(record.Timestamp);\n          if (this.selectedLabel) {\n            // If label is defined, then enumerate timestamps for that label\n            if (record.Name === this.selectedLabel) {\n              saveTimestamp(millisecond);\n            }\n          } else {\n            // No label has been selected, so enumerate timestamps for all label names.\n            saveTimestamp(millisecond);\n          }\n        }.bind(this));\n        //sort the timeseries map by its millisecond key\n        const ordered_timeseries = new Map([...timeseries.entries()].slice().sort((a, b) => a[0] - b[0]));\n        const chartTuples = Array.from(ordered_timeseries.values());\n        this.$store.commit('updateTimeseries', chartTuples);\n        this.$store.commit('updateSelectedLabel', this.selectedLabel);\n      },\n    }\n  }\n</script>\n"]}]}