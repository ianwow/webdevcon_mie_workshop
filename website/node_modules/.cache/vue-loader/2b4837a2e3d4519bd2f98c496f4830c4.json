{"remainingRequest":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ianwow/development/aws-content-analysis/source/website/src/components/LineChart.vue?vue&type=style&index=0&id=6760596c&scoped=true&lang=css&","dependencies":[{"path":"/Users/ianwow/development/aws-content-analysis/source/website/src/components/LineChart.vue","mtime":1623875433274},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/css-loader/index.js","mtime":1633407346668},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1633407349521},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/postcss-loader/src/index.js","mtime":1633407348170},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1633407346687},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js","mtime":1633407348650}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCiNjb250YWluZXIgeyBwb3NpdGlvbjogcmVsYXRpdmU7IH0KLmNhbnZhcyB7CiAgcG9zaXRpb246IGFic29sdXRlOwogIHRvcDogMDsKICBsZWZ0OiAwOwogIHBvaW50ZXItZXZlbnRzOiBub25lOwp9Cg=="},{"version":3,"sources":["LineChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkOA;AACA;AACA;AACA;AACA;AACA;AACA","file":"LineChart.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <b-container>\n    <div v-if=\"isBusy\">\n      <Loading />\n    </div>\n    <div v-else>\n      <div id=\"container\">\n        <canvas id=\"lineChart\" @click=\"handleClick\"></canvas>\n        <canvas id=\"verticalLineCanvas\" class=\"canvas\"></canvas>\n      </div>\n    </div>\n  </b-container>\n</template>\n\n<script>\n  import { mapState } from 'vuex'\n  import Chart from 'chart.js';\n  import Loading from '@/components/Loading.vue'\n\n  export default {\n    name: \"LineChart\",\n    components: {\n      Loading\n    },\n    data() {\n      return {\n        duration: undefined,\n        chartConfig: {},\n        chart: undefined,\n        isBusy: false\n      }\n    },\n    computed: {\n      ...mapState(['chart_tuples', 'selected_label', 'player']),\n    },\n    watch: {\n      chart_tuples: function() {\n        this.renderLineChart();\n      },\n      player: function() {\n        this.getDuration();\n        this.getTimeUpdate();\n        this.renderLineChart();\n      },\n    },\n    deactivated: function () {\n      console.log('deactivated component:', this.operator);\n      this.chart = Object\n    },\n    activated: function () {\n      console.log('activated component:', this.operator)\n    },\n    beforeDestroy: function () {\n      this.chart = Object\n    },\n    mounted: function () {\n      this.chartConfig = {\n        type: 'scatter',\n        data: {\n          labels: [0],\n          datasets: [{\n            data: [0],\n            borderColor: \"#3e95cd\",\n            borderWidth: 3,\n            fill: false,\n            showLine: false\n          }]\n        },\n        options: {\n          legend: {\n            display: false\n          },\n          title: {\n            display: true,\n            text: ''\n          },\n          tooltips: {\n            enabled: false\n          },\n          responsive: true,\n          maintainAspectRatio: false,\n          aspectRatio: 1.5,\n          scales: {\n            yAxes: [{\n              display: true,\n              fixedStepSize: 1,\n              scaleLabel: {\n                display: true,\n                labelString: 'Label Quantity'\n              },\n              ticks: {\n                beginAtZero: true,\n                min: 0,\n                padding: 25,\n                callback: function(value) {\n                  if (Math.floor(value) === value) {\n                    return value;\n                  }\n                }\n              }\n            }],\n            xAxes: [{\n              display: true,\n              scaleLabel: {\n                display: true,\n                labelString: 'Time (mm:ss)'\n              },\n              ticks: {\n                beginAtZero: true,\n                minRotation: 30,\n                min: 0,\n                callback: function(milliseconds) {\n                  if (milliseconds >= 3600000) {\n                    return new Date(milliseconds).toISOString().substr(11, 12);\n                  } else {\n                    // drop hours portion if time is less than 1 hour\n                    return new Date(milliseconds).toISOString().substr(14, 9);\n                  }\n                }\n              }\n            }]\n          },\n        }\n      };\n      window.addEventListener('resize', function () {\n        // TODO: set chart and canvas width equal to video player width\n        // TODO: make columns resize equally when resizing window\n        // Update canvas size when window is resized\n        var chart = document.getElementById('lineChart');\n        var canvas_overlay = document.getElementById('verticalLineCanvas');\n        canvas_overlay.width=chart.width;\n        canvas_overlay.height=chart.height;\n\n      });\n    },\n    methods: {\n      handleClick(event) {\n        var canvas_overlay = document.getElementById('verticalLineCanvas');\n        if (canvas_overlay){\n          const chart_width = this.chart.chart.chartArea.right - this.chart.chart.chartArea.left;\n          const chart_left = this.chart.chart.chartArea.left;\n          // Ignore clicks that are on the chart but to the left of the y-axis\n          if (event.offsetX < chart_left) {\n            return\n          }\n          if (this.duration > 0) {\n            // Calculate click position as a percentage of chart width, to 1/10th precision.\n            const percentage = Math.round((event.offsetX - chart_left) / chart_width * 1000) / 10;\n            this.player.currentTime(this.duration * percentage / 100)\n          }\n        }\n      },\n      getDuration() {\n        // Get the duration for the video player source\n        if (this.player) {\n          this.player.on('loadedmetadata', function () {\n            this.duration = this.player.duration();\n          }.bind(this));\n        }\n      },\n      getTimeUpdate() {\n        // Send current time position for the video player to verticalLineCanvas\n        var last_position = 0;\n        if (this.player) {\n          this.player.on('timeupdate', function () {\n            const current_position = Math.round(this.player.currentTime() / this.player.duration() * 1000);\n            if (current_position !== last_position) {\n              this.drawVerticleLine(current_position/1000);\n              last_position = current_position;\n            }\n          }.bind(this));\n        }\n      },\n      renderLineChart() {\n        const lengthOfVideo = this.duration;\n        const data = this.chart_tuples;\n        const ctx = document.getElementById('lineChart');\n        this.chartConfig.options.title.text = this.selected_label ? this.selected_label + \" (instances / sec)\" : \"Total Labels (instances / sec)\";\n        if (this.chart === undefined) {\n          this.chart = new Chart(ctx, {\n            type: this.chartConfig.type,\n            data: {\n              datasets: [{\n                data: data\n              }]\n            },\n            options: this.chartConfig.options,\n          });\n        } else {\n          this.chart.options.title.text = this.selected_label ? this.selected_label + \" (instances / sec)\" : \"Total Labels (instances / sec)\";\n          if (lengthOfVideo) {\n            this.chart.options.scales.xAxes[0].ticks.max = lengthOfVideo*1000;\n          }\n          if (lengthOfVideo > 3600) {\n            this.chart.options.scales.xAxes[0].scaleLabel.labelString = \"Time (hh:mm:ss)\";\n          }\n\n          this.chart.data.datasets[0].data = null;\n          this.chart.data.datasets[0].data = data;\n          this.chart.lineAtIndex = .25;\n          this.chart.update();\n        }\n        // Place canvas over line chart\n        var canvas_overlay = document.getElementById('verticalLineCanvas');\n        canvas_overlay.width=this.chart.width;\n        canvas_overlay.height=this.chart.height;\n      },\n      drawVerticleLine(position) {\n        var canvas_overlay = document.getElementById('verticalLineCanvas');\n        if (!canvas_overlay) return;\n        var ctx = canvas_overlay.getContext('2d');\n        if (!ctx || !this.chart) return;\n        var scale = this.chart.scales['y-axis-1'];\n        var lineLeftOffset = (this.chart.chart.chartArea.right - this.chart.chart.chartArea.left) * position + this.chart.chart.chartArea.left;\n        ctx.clearRect(0, 0, canvas_overlay.width, canvas_overlay.height);\n        ctx.beginPath();\n        ctx.strokeStyle = '#ff0000';\n        ctx.moveTo(lineLeftOffset, scale.top);\n        ctx.lineTo(lineLeftOffset, scale.bottom+10);\n        ctx.stroke();\n      }\n    }\n  }\n</script>\n\n<style scoped>\n  #container { position: relative; }\n  .canvas {\n    position: absolute;\n    top: 0;\n    left: 0;\n    pointer-events: none;\n  }\n</style>\n"]}]}