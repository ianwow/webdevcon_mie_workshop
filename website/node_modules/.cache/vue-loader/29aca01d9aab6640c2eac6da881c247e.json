{"remainingRequest":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ianwow/development/aws-content-analysis/source/website/src/components/FaceDetection.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ianwow/development/aws-content-analysis/source/website/src/components/FaceDetection.vue","mtime":1637348724761},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/babel-loader/lib/index.js","mtime":1633407348173},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1633407346687},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js","mtime":1633407348650}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBMb2FkaW5nIGZyb20gJ0AvY29tcG9uZW50cy9Mb2FkaW5nLnZ1ZScKaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tICd2dWV4JwoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICJGYWNlRGV0ZWN0aW9uIiwKICBjb21wb25lbnRzOiB7CiAgICBMb2FkaW5nCiAgfSwKICBwcm9wczogewogICAgbWVkaWFUeXBlOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogIiIKICAgIH0sCiAgfSwKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgY3VybENvbW1hbmQ6ICcnLAogICAgICBzZWFyY2hRdWVyeTogJycsCiAgICAgIHNob3dFbGFzdGljc2VhcmNoQXBpUmVxdWVzdDogZmFsc2UsCiAgICAgIENvbmZpZGVuY2U6IDkwLAogICAgICBoaWdoX2NvbmZpZGVuY2VfZGF0YTogW10sCiAgICAgIGVsYXN0aWNzZWFyY2hfZGF0YTogW10sCiAgICAgIGNvdW50X2Rpc3RpbmN0X2xhYmVsczogMCwKICAgICAgY291bnRfbGFiZWxzOiAwLAogICAgICBpc0J1c3k6IGZhbHNlLAogICAgICBvcGVyYXRvcjogJ2ZhY2VfZGV0ZWN0aW9uJywKICAgICAgY2FudmFzUmVmcmVzaEludGVydmFsOiB1bmRlZmluZWQsCiAgICAgIHRpbWVzZXJpZXM6IG5ldyBNYXAoKSwKICAgICAgc2VsZWN0ZWRMYWJlbDogJycsCiAgICAgIGJveGVzX2F2YWlsYWJsZTogW10sCiAgICAgIGxvd2VyQ29uZmlkZW5jZTogZmFsc2UsCiAgICAgIGxvd2VyQ29uZmlkZW5jZU1lc3NhZ2U6ICdUcnkgbG93ZXJpbmcgY29uZmlkZW5jZSB0aHJlc2hvbGQnCiAgICB9CiAgfSwKICBjb21wdXRlZDogewogICAgLi4ubWFwU3RhdGUoWydwbGF5ZXInXSksCiAgICBzb3J0ZWRfdW5pcXVlX2xhYmVscygpIHsKICAgICAgLy8gVGhpcyBmdW5jdGlvbiBzb3J0cyBhbmQgY291bnRzIHVuaXF1ZSBsYWJlbHMgZm9yIG1vdXNlIG92ZXIgZXZlbnRzIG9uIGxhYmVsIGJ1dHRvbnMKICAgICAgY29uc3QgZXNfZGF0YSA9IHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhOwogICAgICBjb25zdCB1bmlxdWVfbGFiZWxzID0gbmV3IE1hcCgpOwogICAgICAvLyBzb3J0IGFuZCBjb3VudCB1bmlxdWUgbGFiZWxzIGZvciBsYWJlbCBtb3VzZSBvdmVyIGV2ZW50cwogICAgICBlc19kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkgewogICAgICAgIHVuaXF1ZV9sYWJlbHMuc2V0KHJlY29yZC5OYW1lLCB1bmlxdWVfbGFiZWxzLmdldChyZWNvcmQuTmFtZSkgPyB1bmlxdWVfbGFiZWxzLmdldChyZWNvcmQuTmFtZSkgKyAxIDogMSk7CiAgICAgICAgaWYgKHJlY29yZC5Cb3VuZGluZ0JveCkgewogICAgICAgICAgLy8gU2F2ZSB0aGlzIGxhYmVsIG5hbWUgdG8gYSBsaXN0IG9mIGxhYmVscyB0aGF0IGhhdmUgYm91bmRpbmcgYm94ZXMKICAgICAgICAgIHRoaXMuc2F2ZUJveGVkTGFiZWwocmVjb3JkLk5hbWUpCiAgICAgICAgfQogICAgICB9LmJpbmQodGhpcykpOwogICAgICBjb25zdCBzb3J0ZWRfdW5pcXVlX2xhYmVscyA9IG5ldyBNYXAoWy4uLnVuaXF1ZV9sYWJlbHMuZW50cmllcygpXS5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKSk7CiAgICAgIC8vIElmIEVsYXN0aWNzZWFyY2ggcmV0dXJuZWQgdW5kZWZpbmVkIGxhYmVscyB0aGVuIGRlbGV0ZSB0aGVtOgogICAgICBzb3J0ZWRfdW5pcXVlX2xhYmVscy5kZWxldGUodW5kZWZpbmVkKTsKICAgICAgdGhpcy5jb3VudExhYmVscyhzb3J0ZWRfdW5pcXVlX2xhYmVscy5zaXplLCBlc19kYXRhLmxlbmd0aCk7CiAgICAgIHJldHVybiBzb3J0ZWRfdW5pcXVlX2xhYmVscwogICAgfQogIH0sCiAgd2F0Y2g6IHsKICAgIC8vIFRoZXNlIHdhdGNoZXMgdXBkYXRlIHRoZSBsaW5lIGNoYXJ0CiAgICBzZWxlY3RlZExhYmVsOiBmdW5jdGlvbigpIHsKICAgICAgdGhpcy5jaGFydERhdGEoKTsKICAgIH0sCiAgICBlbGFzdGljc2VhcmNoX2RhdGE6IGZ1bmN0aW9uKCkgewogICAgICB0aGlzLmNoYXJ0RGF0YSgpOwogICAgfSwKICB9LAogIGRlYWN0aXZhdGVkOiBmdW5jdGlvbiAoKSB7CiAgICBjb25zb2xlLmxvZygnYWN0aXZhdGVkIGNvbXBvbmVudDonLCB0aGlzLm9wZXJhdG9yKTsKICAgIHRoaXMuYm94ZXNfYXZhaWxhYmxlID0gW107CiAgICB0aGlzLnNlbGVjdGVkTGFiZWwgPSAnJzsKICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jYW52YXNSZWZyZXNoSW50ZXJ2YWwpOwogICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpOwogICAgbGV0IGN0eDsKICAgIGlmIChjYW52YXMpIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgaWYgKGN0eCkgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpOwogIH0sCiAgYWN0aXZhdGVkOiBmdW5jdGlvbiAoKSB7CiAgICBjb25zb2xlLmxvZygnYWN0aXZhdGVkIGNvbXBvbmVudDonLCB0aGlzLm9wZXJhdG9yKTsKICAgIHRoaXMuZmV0Y2hBc3NldERhdGEoKTsKICB9LAogIG1vdW50ZWQ6IGZ1bmN0aW9uKCkgewogICAgdGhpcy5nZXRDdXJsQ29tbWFuZCgpOwogIH0sCiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gKCkgewogICAgdGhpcy5oaWdoX2NvbmZpZGVuY2VfZGF0YSA9IFtdOwogICAgdGhpcy5lbGFzdGljc2VhcmNoX2RhdGEgPSBbXTsKICAgIHRoaXMuY291bnRfZGlzdGluY3RfbGFiZWxzID0gMDsKICAgIHRoaXMuY291bnRfbGFiZWxzID0gMDsKICB9LAogIG1ldGhvZHM6IHsKICAgIGdldEN1cmxDb21tYW5kKCkgewogICAgICB0aGlzLnNlYXJjaFF1ZXJ5ID0gJ0Fzc2V0SWQ6Jyt0aGlzLiRyb3V0ZS5wYXJhbXMuYXNzZXRfaWQrJyBDb25maWRlbmNlOj4nK3RoaXMuQ29uZmlkZW5jZSsnIE9wZXJhdG9yOicrdGhpcy5vcGVyYXRvcjsKICAgICAgLy8gZ2V0IGN1cmwgY29tbWFuZCB0byBzZWFyY2ggZWxhc3RpY3NlYXJjaAogICAgICB0aGlzLmN1cmxDb21tYW5kID0gJ2F3c2N1cmwgLVggR0VUIC0tcHJvZmlsZSBkZWZhdWx0IC0tc2VydmljZSBlcyAtLXJlZ2lvbiAnICsgdGhpcy5BV1NfUkVHSU9OICsgJyBcJycgKyB0aGlzLlNFQVJDSF9FTkRQT0lOVCArICcvX3NlYXJjaD9xPScgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5zZWFyY2hRdWVyeSkgKyAnXCcnCiAgICB9LAogICAgYXN5bmMgZmV0Y2hBc3NldERhdGEgKCkgewogICAgICAgIGxldCBhcGlOYW1lID0gJ2NvbnRlbnRBbmFseXNpc0VsYXN0aWNzZWFyY2gnOwogICAgICAgIGxldCBwYXRoID0gJy9fc2VhcmNoJzsKICAgICAgICBsZXQgYXBpUGFyYW1zID0gewogICAgICAgICAgaGVhZGVyczogeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbid9LAogICAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzOiB7J3EnOiB0aGlzLnNlYXJjaFF1ZXJ5LCAnZGVmYXVsdF9vcGVyYXRvcic6ICdBTkQnLCAnc2l6ZSc6IDEwMDAwfQogICAgICAgIH07CiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4kQW1wbGlmeS5BUEkuZ2V0KGFwaU5hbWUsIHBhdGgsIGFwaVBhcmFtcyk7CiAgICAgICAgaWYgKCFyZXNwb25zZSkgewogICAgICAgICAgdGhpcy5zaG93RWxhc3RpY1NlYXJjaEFsZXJ0ID0gdHJ1ZQogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCByZXNwb25zZTsKICAgICAgICAgIGxldCBkYXRhID0gcmVzdWx0LmhpdHMuaGl0czsKICAgICAgICAgIGxldCBlc19kYXRhID0gW107CiAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDAgJiYgdGhpcy5Db25maWRlbmNlID4gNTUpIHsKICAgICAgICAgICAgdGhpcy5sb3dlckNvbmZpZGVuY2UgPSB0cnVlOwogICAgICAgICAgICB0aGlzLmxvd2VyQ29uZmlkZW5jZU1lc3NhZ2UgPSAnVHJ5IGxvd2VyaW5nIGNvbmZpZGVuY2UgdGhyZXNob2xkJwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5sb3dlckNvbmZpZGVuY2UgPSBmYWxzZTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgICBsZXQgaXRlbSA9IGRhdGFbaV0uX3NvdXJjZTsKICAgICAgICAgICAgICBpZiAoIkVtb3Rpb25zIiBpbiBpdGVtKSB7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBlbW90aW9uID0gMCwgZW1vdGlvbnNMZW4gPSBpdGVtLkVtb3Rpb25zLmxlbmd0aDsgZW1vdGlvbiA8IGVtb3Rpb25zTGVuOyBlbW90aW9uKyspIHsKICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uRW1vdGlvbnNbZW1vdGlvbl0uQ29uZmlkZW5jZSA+PSB0aGlzLkNvbmZpZGVuY2UpIHsKICAgICAgICAgICAgICAgICAgICBlc19kYXRhLnB1c2goeyJOYW1lIjogaXRlbS5FbW90aW9uc1tlbW90aW9uXS5UeXBlLCAiVGltZXN0YW1wIjogaXRlbS5UaW1lc3RhbXB9KQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgiQmVhcmQiIGluIGl0ZW0pIHsKICAgICAgICAgICAgICAgIGlmIChpdGVtLkJlYXJkLkNvbmZpZGVuY2UgPiB0aGlzLkNvbmZpZGVuY2UpIHsKICAgICAgICAgICAgICAgICAgZXNfZGF0YS5wdXNoKHsiTmFtZSI6ICJCZWFyZCIsICJUaW1lc3RhbXAiOiBpdGVtLlRpbWVzdGFtcH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgiRXllZ2xhc3NlcyIgaW4gaXRlbSkgewogICAgICAgICAgICAgICAgaWYgKGl0ZW0uRXllZ2xhc3Nlcy5Db25maWRlbmNlID4gdGhpcy5Db25maWRlbmNlKSB7CiAgICAgICAgICAgICAgICAgIGVzX2RhdGEucHVzaCh7Ik5hbWUiOiAiRXllZ2xhc3NlcyIsICJUaW1lc3RhbXAiOiBpdGVtLlRpbWVzdGFtcH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgiRXllc09wZW4iIGluIGl0ZW0pIHsKICAgICAgICAgICAgICAgIGlmIChpdGVtLkV5ZXNPcGVuLkNvbmZpZGVuY2UgPiB0aGlzLkNvbmZpZGVuY2UpIHsKICAgICAgICAgICAgICAgICAgZXNfZGF0YS5wdXNoKHsiTmFtZSI6ICJFeWVzT3BlbiIsICJUaW1lc3RhbXAiOiBpdGVtLlRpbWVzdGFtcH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgiTW91dGhPcGVuIiBpbiBpdGVtKSB7CiAgICAgICAgICAgICAgICBpZiAoaXRlbS5Nb3V0aE9wZW4uQ29uZmlkZW5jZSA+IHRoaXMuQ29uZmlkZW5jZSkgewogICAgICAgICAgICAgICAgICBlc19kYXRhLnB1c2goeyJOYW1lIjogIk1vdXRoT3BlbiIsICJUaW1lc3RhbXAiOiBpdGVtLlRpbWVzdGFtcH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgiTXVzdGFjaGUiIGluIGl0ZW0pIHsKICAgICAgICAgICAgICAgIGlmIChpdGVtLk11c3RhY2hlLkNvbmZpZGVuY2UgPiB0aGlzLkNvbmZpZGVuY2UpIHsKICAgICAgICAgICAgICAgICAgZXNfZGF0YS5wdXNoKHsiTmFtZSI6ICJNdXN0YWNoZSIsICJUaW1lc3RhbXAiOiBpdGVtLlRpbWVzdGFtcH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgiU21pbGUiIGluIGl0ZW0pIHsKICAgICAgICAgICAgICAgIGlmIChpdGVtLlNtaWxlLkNvbmZpZGVuY2UgPiB0aGlzLkNvbmZpZGVuY2UpIHsKICAgICAgICAgICAgICAgICAgZXNfZGF0YS5wdXNoKHsiTmFtZSI6ICJTbWlsZSIsICJUaW1lc3RhbXAiOiBpdGVtLlRpbWVzdGFtcH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgiU3VuZ2xhc3NlcyIgaW4gaXRlbSkgewogICAgICAgICAgICAgICAgaWYgKGl0ZW0uU3VuZ2xhc3Nlcy5Db25maWRlbmNlID4gdGhpcy5Db25maWRlbmNlKSB7CiAgICAgICAgICAgICAgICAgIGVzX2RhdGEucHVzaCh7Ik5hbWUiOiAiU3VuZ2xhc3NlcyIsICJUaW1lc3RhbXAiOiBpdGVtLlRpbWVzdGFtcH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgiR2VuZGVyIiBpbiBpdGVtKSB7CiAgICAgICAgICAgICAgICBlc19kYXRhLnB1c2goeyJOYW1lIjogaXRlbS5HZW5kZXIuVmFsdWUsICJUaW1lc3RhbXAiOiBpdGVtLlRpbWVzdGFtcH0pCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgiQm91bmRpbmdCb3giIGluIGl0ZW0pIHsKICAgICAgICAgICAgICAgIGVzX2RhdGEucHVzaCh7CiAgICAgICAgICAgICAgICAgICJOYW1lIjogIkZhY2UiLAogICAgICAgICAgICAgICAgICAiVGltZXN0YW1wIjogaXRlbS5UaW1lc3RhbXAsCiAgICAgICAgICAgICAgICAgICJDb25maWRlbmNlIjogaXRlbS5Db25maWRlbmNlLAogICAgICAgICAgICAgICAgICAiQm91bmRpbmdCb3giOiB7CiAgICAgICAgICAgICAgICAgICAgIldpZHRoIjogaXRlbS5Cb3VuZGluZ0JveC5XaWR0aCwKICAgICAgICAgICAgICAgICAgICAiSGVpZ2h0IjogaXRlbS5Cb3VuZGluZ0JveC5IZWlnaHQsCiAgICAgICAgICAgICAgICAgICAgIkxlZnQiOiBpdGVtLkJvdW5kaW5nQm94LkxlZnQsCiAgICAgICAgICAgICAgICAgICAgIlRvcCI6IGl0ZW0uQm91bmRpbmdCb3guVG9wCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXNfZGF0YSkpOwogICAgICAgICAgdGhpcy5pc0J1c3kgPSBmYWxzZQogICAgICB9CiAgICB9LAogICAgc2F2ZUJveGVkTGFiZWwobGFiZWxfbmFtZSkgewogICAgICBpZiAoIXRoaXMuYm94ZXNfYXZhaWxhYmxlLmluY2x1ZGVzKGxhYmVsX25hbWUpKSB7CiAgICAgICAgdGhpcy5ib3hlc19hdmFpbGFibGUucHVzaChsYWJlbF9uYW1lKTsKICAgICAgfQogICAgfSwKICAgIGNvdW50TGFiZWxzKHVuaXF1ZV9jb3VudCwgdG90YWxfY291bnQpIHsKICAgICAgdGhpcy5jb3VudF9kaXN0aW5jdF9sYWJlbHMgPSB1bmlxdWVfY291bnQ7CiAgICAgIHRoaXMuY291bnRfbGFiZWxzID0gdG90YWxfY291bnQ7CiAgICB9LAogICAgc2F2ZUZpbGUoKSB7CiAgICAgIGNvbnN0IGVsYXN0aWNzZWFyY2hfZGF0YSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhKTsKICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtlbGFzdGljc2VhcmNoX2RhdGFdLCB7dHlwZTogJ3RleHQvcGxhaW4nfSk7CiAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKSwKICAgICAgICBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpOwogICAgICBhLmRvd25sb2FkID0gImRhdGEuanNvbiI7CiAgICAgIGEuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpOwogICAgICBhLmRhdGFzZXQuZG93bmxvYWR1cmwgPSBbJ3RleHQvanNvbicsIGEuZG93bmxvYWQsIGEuaHJlZl0uam9pbignOicpOwogICAgICBlLmluaXRFdmVudCgnY2xpY2snLCB0cnVlLCBmYWxzZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7CiAgICAgIGEuZGlzcGF0Y2hFdmVudChlKTsKICAgIH0sCiAgICB1cGRhdGVDb25maWRlbmNlIChldmVudCkgewogICAgICB0aGlzLmlzQnVzeSA9IHRydWU7CiAgICAgIHRoaXMuQ29uZmlkZW5jZSA9IGV2ZW50LnRhcmdldC52YWx1ZTsKICAgICAgaWYgKHRoaXMubWVkaWFUeXBlID09PSAidmlkZW8iKSB7CiAgICAgICAgLy8gcmVkcmF3IG1hcmtlcnMgb24gdmlkZW8gdGltZWxpbmUKICAgICAgICB0aGlzLnBsYXllci5tYXJrZXJzLnJlbW92ZUFsbCgpOwogICAgICB9CiAgICAgIHRoaXMuZ2V0Q3VybENvbW1hbmQoKQogICAgICB0aGlzLmZldGNoQXNzZXREYXRhKCkKICAgIH0sCiAgICAvLyB1cGRhdGVNYXJrZXJzIHVwZGF0ZXMgbWFya2VycyBpbiB0aGUgdmlkZW8gcGxheWVyIGFuZCBpcyBjYWxsZWQgd2hlbiBzb21lb25lIGNsaWNrcyBvbiBhIGxhYmVsIGJ1dHRvbgogICAgdXBkYXRlTWFya2VycyAobGFiZWwpIHsKICAgICAgLy8gY2xlYXIgY2FudmFzIGZvciByZWRyYXdpbmcKICAgICAgdGhpcy5ib3hlc19hdmFpbGFibGUgPSBbXTsKICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbnZhc1JlZnJlc2hJbnRlcnZhbCk7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTsKICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7CiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsKICAgICAgY3R4LnN0cm9rZVN0eWxlID0gInJlZCI7CiAgICAgIGN0eC5mb250ID0gIjE1cHggQXJpYWwiOwogICAgICBjdHgudGV4dEFsaWduID0gImNlbnRlciI7CiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAibWlkZGxlIjsKICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZWQiOwogICAgICBpZiAodGhpcy5zZWxlY3RlZExhYmVsID09PSBsYWJlbCkgewogICAgICAgIC8vIGtlZXAgdGhlIGNhbnZhcyBjbGVhciBjYW52YXMgaWYgdXNlciBjbGlja2VkIHRoZSBsYWJlbCBidXR0b24gYSBzZWNvbmQgY29uc2VjdXRpdmUgdGltZQogICAgICAgIHRoaXMuc2VsZWN0ZWRMYWJlbCA9ICIiOwogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIHRoaXMuc2VsZWN0ZWRMYWJlbCA9IGxhYmVsOwogICAgICAvLyBpbml0aWFsaXplIGxpc3RzIG9mIGJveGVzIGFuZCBtYXJrZXJzIHRvIGJlIGRyYXduCiAgICAgIGNvbnN0IGJveE1hcCA9IG5ldyBNYXAoKTsKICAgICAgbGV0IG1hcmtlcnMgPSBbXTsKICAgICAgY29uc3QgZXNfZGF0YSA9IHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhOwogICAgICBsZXQgaW5zdGFuY2UgPSAwOwogICAgICBsZXQgaT0wOwogICAgICBlc19kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkgewogICAgICAgIGlmIChyZWNvcmQuTmFtZSA9PT0gbGFiZWwpIHsKICAgICAgICAgIG1hcmtlcnMucHVzaCh7J3RpbWUnOiByZWNvcmQuVGltZXN0YW1wLzEwMDAsICd0ZXh0JzogcmVjb3JkLk5hbWUsICdvdmVybGF5VGV4dCc6IHJlY29yZC5OYW1lfSk7CiAgICAgICAgICAvLyBTYXZlIGJvdW5kaW5nIGJveCBpbmZvIGlmIGl0IGV4aXN0cwogICAgICAgICAgaWYgKHJlY29yZC5Cb3VuZGluZ0JveCkgewogICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIGltYWdlIHByb2Nlc3NpbmcgdG8gYSBzZXBhcmF0ZSBjb21wb25lbnQKICAgICAgICAgICAgaWYgKHRoaXMubWVkaWFUeXBlID09PSAiaW1hZ2UiKSB7CiAgICAgICAgICAgICAgY29uc3QgYm94aW5mbyA9IHsKICAgICAgICAgICAgICAgICdpbnN0YW5jZSc6IGksCiAgICAgICAgICAgICAgICAnbmFtZSc6IHJlY29yZC5OYW1lLAogICAgICAgICAgICAgICAgJ2NvbmZpZGVuY2UnOiAocmVjb3JkLkNvbmZpZGVuY2UgKiAxKS50b0ZpeGVkKDIpLAogICAgICAgICAgICAgICAgJ3gnOiByZWNvcmQuQm91bmRpbmdCb3guTGVmdCAqIGNhbnZhcy53aWR0aCwKICAgICAgICAgICAgICAgICd5JzogcmVjb3JkLkJvdW5kaW5nQm94LlRvcCAqIGNhbnZhcy5oZWlnaHQsCiAgICAgICAgICAgICAgICAnd2lkdGgnOiByZWNvcmQuQm91bmRpbmdCb3guV2lkdGggKiBjYW52YXMud2lkdGgsCiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogcmVjb3JkLkJvdW5kaW5nQm94LkhlaWdodCAqIGNhbnZhcy5oZWlnaHQKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIGJveE1hcC5zZXQoaSsrLCBbYm94aW5mb10pCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgLy8gVXNlIHRpbWUgcmVzb2x1dGlvbiBvZiAwLjEgc2Vjb25kCiAgICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5yb3VuZChyZWNvcmQuVGltZXN0YW1wIC8gMTAwKTsKICAgICAgICAgICAgICBpZiAoYm94TWFwLmhhcyh0aW1lc3RhbXApKSB7CiAgICAgICAgICAgICAgICBjb25zdCBib3hpbmZvID0gewogICAgICAgICAgICAgICAgICAnaW5zdGFuY2UnOiBpbnN0YW5jZSsrLAogICAgICAgICAgICAgICAgICAndGltZXN0YW1wJzogTWF0aC5jZWlsKHJlY29yZC5UaW1lc3RhbXAgLyAxMDApLAogICAgICAgICAgICAgICAgICAnbmFtZSc6IHJlY29yZC5OYW1lLAogICAgICAgICAgICAgICAgICAnY29uZmlkZW5jZSc6IChyZWNvcmQuQ29uZmlkZW5jZSAqIDEpLnRvRml4ZWQoMiksCiAgICAgICAgICAgICAgICAgICd4JzogcmVjb3JkLkJvdW5kaW5nQm94LkxlZnQgKiBjYW52YXMud2lkdGgsCiAgICAgICAgICAgICAgICAgICd5JzogcmVjb3JkLkJvdW5kaW5nQm94LlRvcCAqIGNhbnZhcy5oZWlnaHQsCiAgICAgICAgICAgICAgICAgICd3aWR0aCc6IHJlY29yZC5Cb3VuZGluZ0JveC5XaWR0aCAqIGNhbnZhcy53aWR0aCwKICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6IHJlY29yZC5Cb3VuZGluZ0JveC5IZWlnaHQgKiBjYW52YXMuaGVpZ2h0CiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgYm94TWFwLmdldCh0aW1lc3RhbXApLnB1c2goYm94aW5mbykKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgaW5zdGFuY2UgPSAwOwogICAgICAgICAgICAgICAgY29uc3QgYm94aW5mbyA9IHsKICAgICAgICAgICAgICAgICAgJ2luc3RhbmNlJzogaW5zdGFuY2UrKywKICAgICAgICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IE1hdGguY2VpbChyZWNvcmQuVGltZXN0YW1wIC8gMTAwKSwKICAgICAgICAgICAgICAgICAgJ25hbWUnOiByZWNvcmQuTmFtZSwKICAgICAgICAgICAgICAgICAgJ2NvbmZpZGVuY2UnOiAocmVjb3JkLkNvbmZpZGVuY2UgKiAxKS50b0ZpeGVkKDIpLAogICAgICAgICAgICAgICAgICAneCc6IHJlY29yZC5Cb3VuZGluZ0JveC5MZWZ0ICogY2FudmFzLndpZHRoLAogICAgICAgICAgICAgICAgICAneSc6IHJlY29yZC5Cb3VuZGluZ0JveC5Ub3AgKiBjYW52YXMuaGVpZ2h0LAogICAgICAgICAgICAgICAgICAnd2lkdGgnOiByZWNvcmQuQm91bmRpbmdCb3guV2lkdGggKiBjYW52YXMud2lkdGgsCiAgICAgICAgICAgICAgICAgICdoZWlnaHQnOiByZWNvcmQuQm91bmRpbmdCb3guSGVpZ2h0ICogY2FudmFzLmhlaWdodAogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIGJveE1hcC5zZXQodGltZXN0YW1wLCBbYm94aW5mb10pCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LmJpbmQodGhpcykpOwogICAgICBpZiAoYm94TWFwLnNpemUgPiAwKSB7CiAgICAgICAgdGhpcy5kcmF3Qm94ZXMoYm94TWFwKTsKICAgICAgfQogICAgICAvLyBUT0RPOiBtb3ZlIGltYWdlIHByb2Nlc3NpbmcgdG8gYSBzZXBhcmF0ZSBjb21wb25lbnQKICAgICAgaWYgKHRoaXMubWVkaWFUeXBlID09PSAidmlkZW8iKSB7CiAgICAgICAgLy8gcmVkcmF3IG1hcmtlcnMgb24gdmlkZW8gdGltZWxpbmUKICAgICAgICB0aGlzLnBsYXllci5tYXJrZXJzLnJlbW92ZUFsbCgpOwogICAgICAgIHRoaXMucGxheWVyLm1hcmtlcnMuYWRkKG1hcmtlcnMpOwogICAgICB9CiAgICB9LAogICAgZHJhd0JveGVzOiBmdW5jdGlvbihib3hNYXApIHsKICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpOwogICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgICAgLy8gVE9ETzogbW92ZSBpbWFnZSBwcm9jZXNzaW5nIHRvIGEgc2VwYXJhdGUgY29tcG9uZW50CiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZSA9PT0gImltYWdlIikgewogICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsKICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gInJlZCI7CiAgICAgICAgY3R4LmZvbnQgPSAiMTVweCBBcmlhbCI7CiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICJjZW50ZXIiOwogICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAibWlkZGxlIjsKICAgICAgICBjdHguZmlsbFN0eWxlID0gInJlZCI7CiAgICAgICAgLy8gRm9yIGVhY2ggYm94IGluc3RhbmNlLi4uCiAgICAgICAgYm94TWFwLmZvckVhY2goIGkgPT4gewogICAgICAgICAgbGV0IGRyYXdNZSA9IGlbMF07CiAgICAgICAgICBpZiAoZHJhd01lKSB7CiAgICAgICAgICAgIGN0eC5yZWN0KGRyYXdNZS54LCBkcmF3TWUueSwgZHJhd01lLndpZHRoLCBkcmF3TWUuaGVpZ2h0KTsKICAgICAgICAgICAgLy8gRHJhdyBvYmplY3QgbmFtZSBhbmQgY29uZmlkZW5jZSBzY29yZQogICAgICAgICAgICBjdHguZmlsbFRleHQoZHJhd01lLm5hbWUgKyAiICgiICsgZHJhd01lLmNvbmZpZGVuY2UgKyAiJSkiLCAoZHJhd01lLnggKyBkcmF3TWUud2lkdGggLyAyKSwgZHJhd01lLnkgLSAxMCk7CiAgICAgICAgICAgIGN0eC5zdHJva2UoKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICAvLyBub3cgcmV0dXJuIHNvIHdlIGF2b2lkIHJlbmRlcmluZyBhbnkgb2YgdGhlIHZpZGVvIHJlbGF0ZWQgY29tcG9uZW50cyBiZWxvdwogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIC8vIElmIHVzZXIganVzdCBjbGlja2VkIGEgbmV3IGxhYmVsLi4uCiAgICAgIGlmICh0aGlzLmNhbnZhc1JlZnJlc2hJbnRlcnZhbCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgLy8gLi4udGhlbiByZXNldCB0aGUgb2xkIGNhbnZhcyByZWZyZXNoIGludGVydmFsLgogICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jYW52YXNSZWZyZXNoSW50ZXJ2YWwpCiAgICAgIH0KICAgICAgLy8gTG9vayBmb3IgYW5kIGRyYXcgYm91bmRpbmcgYm94ZXMgZXZlcnkgMTAwbXMKICAgICAgY29uc3QgaW50ZXJ2YWxfbXMgPSAxMDA7CiAgICAgIGNvbnN0IGVyYXNlX29uX2l0ZXJhdGlvbiA9IDI7CiAgICAgIGxldCBpID0gMDsKICAgICAgdGhpcy5jYW52YXNSZWZyZXNoSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7CiAgICAgICAgaSsrOwogICAgICAgIC8vIGVyYXNlIG9sZCBib3VuZGluZyBib3hlcwogICAgICAgIGlmICghdGhpcy5wbGF5ZXIucGF1c2VkKCkgJiYgaSAlIGVyYXNlX29uX2l0ZXJhdGlvbiA9PT0gMCkgewogICAgICAgICAgaT0wOwogICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpOwogICAgICAgICAgY3R4LmJlZ2luUGF0aCgpOwogICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gInJlZCI7CiAgICAgICAgICBjdHguZm9udCA9ICIxNXB4IEFyaWFsIjsKICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAiY2VudGVyIjsKICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAibWlkZGxlIjsKICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAicmVkIjsKICAgICAgICB9CiAgICAgICAgLy8gR2V0IGN1cnJlbnQgcGxheWVyIHRpbWVzdGFtcCB0byB0aGUgbmVhcmVzdCAxLzEwdGggc2Vjb25kCiAgICAgICAgY29uc3QgcGxheWVyX3RpbWVzdGFtcCA9IE1hdGgucm91bmQodGhpcy5wbGF5ZXIuY3VycmVudFRpbWUoKSoxMC4wKTsKICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgYm94IGZvciB0aGUgcGxheWVyJ3MgdGltZXN0YW1wLi4uCiAgICAgICAgaWYgKGJveE1hcC5oYXMocGxheWVyX3RpbWVzdGFtcCkpIHsKICAgICAgICAgIGk9MDsKICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsKICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTsKICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICJyZWQiOwogICAgICAgICAgY3R4LmZvbnQgPSAiMTVweCBBcmlhbCI7CiAgICAgICAgICBjdHgudGV4dEFsaWduID0gImNlbnRlciI7CiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gIm1pZGRsZSI7CiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gInJlZCI7CiAgICAgICAgICAvLyAuLi50aGVuIGdldCBhIGxpc3Qgb2YgYm94IGluc3RhbmNlcwogICAgICAgICAgY29uc3QgaW5zdGFuY2VfbGlzdCA9IChib3hNYXAuZ2V0KHBsYXllcl90aW1lc3RhbXApKS5tYXAoIGl0ZW0gPT4gaXRlbS5pbnN0YW5jZSkuZmlsdGVyKCh2LCBpLCBhKSA9PiBhLmluZGV4T2YodikgPT09IGkpOwogICAgICAgICAgLy8gRm9yIGVhY2ggYm94IGluc3RhbmNlLi4uCiAgICAgICAgICBpbnN0YW5jZV9saXN0LmZvckVhY2goIGkgPT4gewogICAgICAgICAgICAvLyAuLi5nZXQgYWxsIG9mIHRoZSBib3hlcyBiZWxvbmdpbmcgdG8gdGhpcyBpbnN0YW5jZQogICAgICAgICAgICAvLyBhdCB0aGUgY3VycmVudCB0aW1lc3RhbXAuCiAgICAgICAgICAgIGNvbnN0IGJveGVzID0gYm94TWFwLmdldChwbGF5ZXJfdGltZXN0YW1wKS5maWx0ZXIoYm94ID0+IGJveC5pbnN0YW5jZSA9PT0gaSk7CiAgICAgICAgICAgIGJveGVzLmZvckVhY2ggKGRyYXdNZSA9PiB7CiAgICAgICAgICAgICAgaWYgKGRyYXdNZSkgewogICAgICAgICAgICAgICAgY3R4LnJlY3QoZHJhd01lLngsIGRyYXdNZS55LCBkcmF3TWUud2lkdGgsIGRyYXdNZS5oZWlnaHQpOwogICAgICAgICAgICAgICAgLy8gRHJhdyBvYmplY3QgbmFtZSBhbmQgY29uZmlkZW5jZSBzY29yZQogICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGRyYXdNZS5uYW1lICsgIiAoIiArIGRyYXdNZS5jb25maWRlbmNlICsgIiUpIiwgKGRyYXdNZS54ICsgZHJhd01lLndpZHRoIC8gMiksIGRyYXdNZS55IC0gMTApOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkKICAgICAgICAgIH0pOwogICAgICAgICAgY3R4LnN0cm9rZSgpOwogICAgICAgIH0KICAgICAgfS5iaW5kKHRoaXMpLCBpbnRlcnZhbF9tcyk7CiAgICB9LAogICAgY2hhcnREYXRhKCkgewogICAgICBsZXQgdGltZXNlcmllcyA9IG5ldyBNYXAoKTsKICAgICAgZnVuY3Rpb24gc2F2ZVRpbWVzdGFtcCAobWlsbGlzZWNvbmQpIHsKICAgICAgICBpZiAodGltZXNlcmllcy5oYXMobWlsbGlzZWNvbmQpKSB7CiAgICAgICAgICB0aW1lc2VyaWVzLnNldChtaWxsaXNlY29uZCwgeyJ4IjogbWlsbGlzZWNvbmQsICJ5IjogdGltZXNlcmllcy5nZXQobWlsbGlzZWNvbmQpLnkgKyAxfSkKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGltZXNlcmllcy5zZXQobWlsbGlzZWNvbmQsIHsieCI6IG1pbGxpc2Vjb25kLCAieSI6MX0pCiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IGVzX2RhdGEgPSB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YTsKICAgICAgZXNfZGF0YS5mb3JFYWNoKCBmdW5jdGlvbihyZWNvcmQpIHsKICAgICAgICAvLyBEZWZpbmUgdGltZXN0YW1wIHdpdGggbWlsbGlzZWNvbmQgcmVzb2x1dGlvbgogICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChyZWNvcmQuVGltZXN0YW1wKTsKICAgICAgICBpZiAodGhpcy5zZWxlY3RlZExhYmVsKSB7CiAgICAgICAgICAvLyBObyBsYWJlbCBoYXMgYmVlbiBzZWxlY3RlZCwgc28gZW51bWVyYXRlIHRpbWVzdGFtcHMgZm9yIGFsbCBsYWJlbCBuYW1lcy4KICAgICAgICAgIGlmIChyZWNvcmQuTmFtZSA9PT0gdGhpcy5zZWxlY3RlZExhYmVsKSB7CiAgICAgICAgICAgIHNhdmVUaW1lc3RhbXAobWlsbGlzZWNvbmQpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBMYWJlbCBpcyB1bmRlZmluZWQuIEVudW1lcmF0ZSB0aW1lc3RhbXBzIGZvciBhbGwgbGFiZWwgbmFtZXMuCiAgICAgICAgICBzYXZlVGltZXN0YW1wKG1pbGxpc2Vjb25kKTsKICAgICAgICB9CiAgICAgIH0uYmluZCh0aGlzKSk7CiAgICAgIC8vc29ydCB0aGUgdGltZXNlcmllcyBtYXAgYnkgaXRzIG1pbGxpc2Vjb25kIGtleQogICAgICBjb25zdCBvcmRlcmVkX3RpbWVzZXJpZXMgPSBuZXcgTWFwKFsuLi50aW1lc2VyaWVzLmVudHJpZXMoKV0uc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSkpOwogICAgICBjb25zdCBjaGFydFR1cGxlcyA9IEFycmF5LmZyb20ob3JkZXJlZF90aW1lc2VyaWVzLnZhbHVlcygpKTsKICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCd1cGRhdGVUaW1lc2VyaWVzJywgY2hhcnRUdXBsZXMpOwogICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3VwZGF0ZVNlbGVjdGVkTGFiZWwnLCB0aGlzLnNlbGVjdGVkTGFiZWwpOwogICAgfSwKICB9Cn0K"},{"version":3,"sources":["FaceDetection.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmHA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"FaceDetection.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <b-container fluid>\n    <b-col>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          Confidence Threshold<br>\n          <input\n            type=\"range\"\n            value=\"90\"\n            min=\"55\"\n            max=\"99\"\n            step=\"1\"\n            @click=\"updateConfidence\"\n          >\n          {{ Confidence }}%<br>\n        </div>\n      </b-row>\n      <div v-if=\"lowerConfidence === true\">\n        {{ lowerConfidenceMessage }}\n      </div>\n      <div\n        v-if=\"isBusy\"\n        class=\"wrapper\"\n      >\n        <Loading />\n      </div>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          <br>\n          <template v-for=\"label in sorted_unique_labels\">\n            <template v-if=\"boxes_available.includes(label[0])\">\n              <!-- Show darker button outline if boxes are available for the label -->\n              <b-button\n                v-b-tooltip.hover\n                variant=\"outline-dark\"\n                :title=\"label[1]\"\n                size=\"sm\"\n                pill\n                @click=\"updateMarkers(label[0])\"\n              >\n                {{ label[0]+\"*\" }}\n              </b-button> &nbsp;\n            </template>\n            <template v-else>\n              <b-button\n                v-b-tooltip.hover\n                variant=\"outline-secondary\"\n                :title=\"label[1]\"\n                size=\"sm\"\n                pill\n                @click=\"updateMarkers(label[0])\"\n              >\n                {{ label[0] }}\n              </b-button> &nbsp;\n            </template>\n          </template>\n        </div>\n      </b-row>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div\n          v-if=\"isBusy === false\"\n          class=\"wrapper\"\n        >\n          <br><p class=\"text-muted\">\n            ({{ count_labels }} identified objects, {{ count_distinct_labels }} unique)\n          </p>\n          <hr>\n          <p class=\"text-muted\">\n            * Indicates bounding boxes are available.\n          </p>\n        </div>\n      </b-row>\n    </b-col>\n    <b-button\n      type=\"button\"\n      @click=\"saveFile()\"\n    >\n      Download Data\n    </b-button>\n    <br>\n    <b-button\n        :pressed=\"false\"\n        size=\"sm\"\n        variant=\"link\"\n        class=\"text-decoration-none\"\n        @click=\"showElasticsearchApiRequest = true\"\n    >\n      Show API request to get these results\n    </b-button>\n    <b-modal\n        v-model=\"showElasticsearchApiRequest\"\n        scrollable\n        title=\"SEARCH API\"\n        ok-only\n    >\n      <label>Request URL:</label>\n      <pre v-highlightjs><code class=\"bash\">GET {{ SEARCH_ENDPOINT }}workflow/execution</code></pre>\n      <label>Search query:</label>\n      <pre v-highlightjs=\"JSON.stringify(searchQuery)\"><code class=\"json\"></code></pre>\n      <label>Sample command:</label>\n      <pre v-highlightjs=\"curlCommand\"><code class=\"bash\"></code></pre>\n    </b-modal>\n  </b-container>\n</template>\n\n<script>\n  import Loading from '@/components/Loading.vue'\n  import { mapState } from 'vuex'\n\n  export default {\n    name: \"FaceDetection\",\n    components: {\n      Loading\n    },\n    props: {\n      mediaType: {\n        type: String,\n        default: \"\"\n      },\n    },\n    data() {\n      return {\n        curlCommand: '',\n        searchQuery: '',\n        showElasticsearchApiRequest: false,\n        Confidence: 90,\n        high_confidence_data: [],\n        elasticsearch_data: [],\n        count_distinct_labels: 0,\n        count_labels: 0,\n        isBusy: false,\n        operator: 'face_detection',\n        canvasRefreshInterval: undefined,\n        timeseries: new Map(),\n        selectedLabel: '',\n        boxes_available: [],\n        lowerConfidence: false,\n        lowerConfidenceMessage: 'Try lowering confidence threshold'\n      }\n    },\n    computed: {\n      ...mapState(['player']),\n      sorted_unique_labels() {\n        // This function sorts and counts unique labels for mouse over events on label buttons\n        const es_data = this.elasticsearch_data;\n        const unique_labels = new Map();\n        // sort and count unique labels for label mouse over events\n        es_data.forEach(function (record) {\n          unique_labels.set(record.Name, unique_labels.get(record.Name) ? unique_labels.get(record.Name) + 1 : 1);\n          if (record.BoundingBox) {\n            // Save this label name to a list of labels that have bounding boxes\n            this.saveBoxedLabel(record.Name)\n          }\n        }.bind(this));\n        const sorted_unique_labels = new Map([...unique_labels.entries()].slice().sort((a, b) => b[1] - a[1]));\n        // If Elasticsearch returned undefined labels then delete them:\n        sorted_unique_labels.delete(undefined);\n        this.countLabels(sorted_unique_labels.size, es_data.length);\n        return sorted_unique_labels\n      }\n    },\n    watch: {\n      // These watches update the line chart\n      selectedLabel: function() {\n        this.chartData();\n      },\n      elasticsearch_data: function() {\n        this.chartData();\n      },\n    },\n    deactivated: function () {\n      console.log('activated component:', this.operator);\n      this.boxes_available = [];\n      this.selectedLabel = '';\n      clearInterval(this.canvasRefreshInterval);\n      const canvas = document.getElementById('canvas');\n      let ctx;\n      if (canvas) ctx = canvas.getContext('2d');\n      if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);\n    },\n    activated: function () {\n      console.log('activated component:', this.operator);\n      this.fetchAssetData();\n    },\n    mounted: function() {\n      this.getCurlCommand();\n    },\n    beforeDestroy: function () {\n      this.high_confidence_data = [];\n      this.elasticsearch_data = [];\n      this.count_distinct_labels = 0;\n      this.count_labels = 0;\n    },\n    methods: {\n      getCurlCommand() {\n        this.searchQuery = 'AssetId:'+this.$route.params.asset_id+' Confidence:>'+this.Confidence+' Operator:'+this.operator;\n        // get curl command to search elasticsearch\n        this.curlCommand = 'awscurl -X GET --profile default --service es --region ' + this.AWS_REGION + ' \\'' + this.SEARCH_ENDPOINT + '/_search?q=' + encodeURIComponent(this.searchQuery) + '\\''\n      },\n      async fetchAssetData () {\n          let apiName = 'contentAnalysisElasticsearch';\n          let path = '/_search';\n          let apiParams = {\n            headers: {'Content-Type': 'application/json'},\n            queryStringParameters: {'q': this.searchQuery, 'default_operator': 'AND', 'size': 10000}\n          };\n          let response = await this.$Amplify.API.get(apiName, path, apiParams);\n          if (!response) {\n            this.showElasticSearchAlert = true\n          }\n          else {\n            let result = await response;\n            let data = result.hits.hits;\n            let es_data = [];\n            if (data.length === 0 && this.Confidence > 55) {\n              this.lowerConfidence = true;\n              this.lowerConfidenceMessage = 'Try lowering confidence threshold'\n            } else {\n              this.lowerConfidence = false;\n              for (let i = 0, len = data.length; i < len; i++) {\n                let item = data[i]._source;\n                if (\"Emotions\" in item) {\n                  for (let emotion = 0, emotionsLen = item.Emotions.length; emotion < emotionsLen; emotion++) {\n                    if (item.Emotions[emotion].Confidence >= this.Confidence) {\n                      es_data.push({\"Name\": item.Emotions[emotion].Type, \"Timestamp\": item.Timestamp})\n                    }\n                  }\n                }\n                if (\"Beard\" in item) {\n                  if (item.Beard.Confidence > this.Confidence) {\n                    es_data.push({\"Name\": \"Beard\", \"Timestamp\": item.Timestamp})\n                  }\n                }\n                if (\"Eyeglasses\" in item) {\n                  if (item.Eyeglasses.Confidence > this.Confidence) {\n                    es_data.push({\"Name\": \"Eyeglasses\", \"Timestamp\": item.Timestamp})\n                  }\n                }\n                if (\"EyesOpen\" in item) {\n                  if (item.EyesOpen.Confidence > this.Confidence) {\n                    es_data.push({\"Name\": \"EyesOpen\", \"Timestamp\": item.Timestamp})\n                  }\n                }\n                if (\"MouthOpen\" in item) {\n                  if (item.MouthOpen.Confidence > this.Confidence) {\n                    es_data.push({\"Name\": \"MouthOpen\", \"Timestamp\": item.Timestamp})\n                  }\n                }\n                if (\"Mustache\" in item) {\n                  if (item.Mustache.Confidence > this.Confidence) {\n                    es_data.push({\"Name\": \"Mustache\", \"Timestamp\": item.Timestamp})\n                  }\n                }\n                if (\"Smile\" in item) {\n                  if (item.Smile.Confidence > this.Confidence) {\n                    es_data.push({\"Name\": \"Smile\", \"Timestamp\": item.Timestamp})\n                  }\n                }\n                if (\"Sunglasses\" in item) {\n                  if (item.Sunglasses.Confidence > this.Confidence) {\n                    es_data.push({\"Name\": \"Sunglasses\", \"Timestamp\": item.Timestamp})\n                  }\n                }\n                if (\"Gender\" in item) {\n                  es_data.push({\"Name\": item.Gender.Value, \"Timestamp\": item.Timestamp})\n                }\n                if (\"BoundingBox\" in item) {\n                  es_data.push({\n                    \"Name\": \"Face\",\n                    \"Timestamp\": item.Timestamp,\n                    \"Confidence\": item.Confidence,\n                    \"BoundingBox\": {\n                      \"Width\": item.BoundingBox.Width,\n                      \"Height\": item.BoundingBox.Height,\n                      \"Left\": item.BoundingBox.Left,\n                      \"Top\": item.BoundingBox.Top\n                    }\n                  })\n                }\n              }\n            }\n            this.elasticsearch_data = JSON.parse(JSON.stringify(es_data));\n            this.isBusy = false\n        }\n      },\n      saveBoxedLabel(label_name) {\n        if (!this.boxes_available.includes(label_name)) {\n          this.boxes_available.push(label_name);\n        }\n      },\n      countLabels(unique_count, total_count) {\n        this.count_distinct_labels = unique_count;\n        this.count_labels = total_count;\n      },\n      saveFile() {\n        const elasticsearch_data = JSON.stringify(this.elasticsearch_data);\n        const blob = new Blob([elasticsearch_data], {type: 'text/plain'});\n        const e = document.createEvent('MouseEvents'),\n          a = document.createElement('a');\n        a.download = \"data.json\";\n        a.href = window.URL.createObjectURL(blob);\n        a.dataset.downloadurl = ['text/json', a.download, a.href].join(':');\n        e.initEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n        a.dispatchEvent(e);\n      },\n      updateConfidence (event) {\n        this.isBusy = true;\n        this.Confidence = event.target.value;\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n        }\n        this.getCurlCommand()\n        this.fetchAssetData()\n      },\n      // updateMarkers updates markers in the video player and is called when someone clicks on a label button\n      updateMarkers (label) {\n        // clear canvas for redrawing\n        this.boxes_available = [];\n        clearInterval(this.canvasRefreshInterval);\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.strokeStyle = \"red\";\n        ctx.font = \"15px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillStyle = \"red\";\n        if (this.selectedLabel === label) {\n          // keep the canvas clear canvas if user clicked the label button a second consecutive time\n          this.selectedLabel = \"\";\n          return\n        }\n        this.selectedLabel = label;\n        // initialize lists of boxes and markers to be drawn\n        const boxMap = new Map();\n        let markers = [];\n        const es_data = this.elasticsearch_data;\n        let instance = 0;\n        let i=0;\n        es_data.forEach(function (record) {\n          if (record.Name === label) {\n            markers.push({'time': record.Timestamp/1000, 'text': record.Name, 'overlayText': record.Name});\n            // Save bounding box info if it exists\n            if (record.BoundingBox) {\n              // TODO: move image processing to a separate component\n              if (this.mediaType === \"image\") {\n                const boxinfo = {\n                  'instance': i,\n                  'name': record.Name,\n                  'confidence': (record.Confidence * 1).toFixed(2),\n                  'x': record.BoundingBox.Left * canvas.width,\n                  'y': record.BoundingBox.Top * canvas.height,\n                  'width': record.BoundingBox.Width * canvas.width,\n                  'height': record.BoundingBox.Height * canvas.height\n                };\n                boxMap.set(i++, [boxinfo])\n              } else {\n                // Use time resolution of 0.1 second\n                const timestamp = Math.round(record.Timestamp / 100);\n                if (boxMap.has(timestamp)) {\n                  const boxinfo = {\n                    'instance': instance++,\n                    'timestamp': Math.ceil(record.Timestamp / 100),\n                    'name': record.Name,\n                    'confidence': (record.Confidence * 1).toFixed(2),\n                    'x': record.BoundingBox.Left * canvas.width,\n                    'y': record.BoundingBox.Top * canvas.height,\n                    'width': record.BoundingBox.Width * canvas.width,\n                    'height': record.BoundingBox.Height * canvas.height\n                  };\n                  boxMap.get(timestamp).push(boxinfo)\n                } else {\n                  instance = 0;\n                  const boxinfo = {\n                    'instance': instance++,\n                    'timestamp': Math.ceil(record.Timestamp / 100),\n                    'name': record.Name,\n                    'confidence': (record.Confidence * 1).toFixed(2),\n                    'x': record.BoundingBox.Left * canvas.width,\n                    'y': record.BoundingBox.Top * canvas.height,\n                    'width': record.BoundingBox.Width * canvas.width,\n                    'height': record.BoundingBox.Height * canvas.height\n                  };\n                  boxMap.set(timestamp, [boxinfo])\n                }\n              }\n            }\n          }\n        }.bind(this));\n        if (boxMap.size > 0) {\n          this.drawBoxes(boxMap);\n        }\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n          this.player.markers.add(markers);\n        }\n      },\n      drawBoxes: function(boxMap) {\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"image\") {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.strokeStyle = \"red\";\n          ctx.font = \"15px Arial\";\n          ctx.textAlign = \"center\";\n          ctx.textBaseline = \"middle\";\n          ctx.fillStyle = \"red\";\n          // For each box instance...\n          boxMap.forEach( i => {\n            let drawMe = i[0];\n            if (drawMe) {\n              ctx.rect(drawMe.x, drawMe.y, drawMe.width, drawMe.height);\n              // Draw object name and confidence score\n              ctx.fillText(drawMe.name + \" (\" + drawMe.confidence + \"%)\", (drawMe.x + drawMe.width / 2), drawMe.y - 10);\n              ctx.stroke();\n            }\n          });\n          // now return so we avoid rendering any of the video related components below\n          return\n        }\n        // If user just clicked a new label...\n        if (this.canvasRefreshInterval !== undefined) {\n          // ...then reset the old canvas refresh interval.\n          clearInterval(this.canvasRefreshInterval)\n        }\n        // Look for and draw bounding boxes every 100ms\n        const interval_ms = 100;\n        const erase_on_iteration = 2;\n        let i = 0;\n        this.canvasRefreshInterval = setInterval(function () {\n          i++;\n          // erase old bounding boxes\n          if (!this.player.paused() && i % erase_on_iteration === 0) {\n            i=0;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.beginPath();\n            ctx.strokeStyle = \"red\";\n            ctx.font = \"15px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = \"red\";\n          }\n          // Get current player timestamp to the nearest 1/10th second\n          const player_timestamp = Math.round(this.player.currentTime()*10.0);\n          // If we have a box for the player's timestamp...\n          if (boxMap.has(player_timestamp)) {\n            i=0;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.beginPath();\n            ctx.strokeStyle = \"red\";\n            ctx.font = \"15px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = \"red\";\n            // ...then get a list of box instances\n            const instance_list = (boxMap.get(player_timestamp)).map( item => item.instance).filter((v, i, a) => a.indexOf(v) === i);\n            // For each box instance...\n            instance_list.forEach( i => {\n              // ...get all of the boxes belonging to this instance\n              // at the current timestamp.\n              const boxes = boxMap.get(player_timestamp).filter(box => box.instance === i);\n              boxes.forEach (drawMe => {\n                if (drawMe) {\n                  ctx.rect(drawMe.x, drawMe.y, drawMe.width, drawMe.height);\n                  // Draw object name and confidence score\n                  ctx.fillText(drawMe.name + \" (\" + drawMe.confidence + \"%)\", (drawMe.x + drawMe.width / 2), drawMe.y - 10);\n                }\n              })\n            });\n            ctx.stroke();\n          }\n        }.bind(this), interval_ms);\n      },\n      chartData() {\n        let timeseries = new Map();\n        function saveTimestamp (millisecond) {\n          if (timeseries.has(millisecond)) {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\": timeseries.get(millisecond).y + 1})\n          } else {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\":1})\n          }\n        }\n        const es_data = this.elasticsearch_data;\n        es_data.forEach( function(record) {\n          // Define timestamp with millisecond resolution\n          const millisecond = Math.round(record.Timestamp);\n          if (this.selectedLabel) {\n            // No label has been selected, so enumerate timestamps for all label names.\n            if (record.Name === this.selectedLabel) {\n              saveTimestamp(millisecond);\n            }\n          } else {\n            // Label is undefined. Enumerate timestamps for all label names.\n            saveTimestamp(millisecond);\n          }\n        }.bind(this));\n        //sort the timeseries map by its millisecond key\n        const ordered_timeseries = new Map([...timeseries.entries()].slice().sort((a, b) => a[0] - b[0]));\n        const chartTuples = Array.from(ordered_timeseries.values());\n        this.$store.commit('updateTimeseries', chartTuples);\n        this.$store.commit('updateSelectedLabel', this.selectedLabel);\n      },\n    }\n  }\n</script>\n"]}]}