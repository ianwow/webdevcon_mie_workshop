{"remainingRequest":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ianwow/development/aws-content-analysis/source/website/src/components/LabelObjects.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ianwow/development/aws-content-analysis/source/website/src/components/LabelObjects.vue","mtime":1638395687236},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1633407346687},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/thread-loader/dist/cjs.js","mtime":1633407346686},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/babel-loader/lib/index.js","mtime":1633407348173},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1633407346687},{"path":"/Users/ianwow/development/aws-content-analysis/source/website/node_modules/vue-loader/lib/index.js","mtime":1633407348650}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBMb2FkaW5nIGZyb20gJ0AvY29tcG9uZW50cy9Mb2FkaW5nLnZ1ZScKaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tICd2dWV4JwpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogIkxhYmVsT2JqZWN0cyIsCiAgY29tcG9uZW50czogewogICAgTG9hZGluZwogIH0sCiAgcHJvcHM6IHsKICAgIG1lZGlhVHlwZTogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICIiCiAgICB9LAogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIENvbmZpZGVuY2U6IDkwLAogICAgICBoaWdoX2NvbmZpZGVuY2VfZGF0YTogW10sCiAgICAgIGVsYXN0aWNzZWFyY2hfZGF0YTogW10sCiAgICAgIGJveGVzX2F2YWlsYWJsZTogW10sCiAgICAgIGNvdW50X2Rpc3RpbmN0X2xhYmVsczogMCwKICAgICAgY291bnRfbGFiZWxzOiAwLAogICAgICBpc0J1c3k6IGZhbHNlLAogICAgICBvcGVyYXRvcjogJ2xhYmVsX2RldGVjdGlvbicsCiAgICAgIGNhbnZhc1JlZnJlc2hJbnRlcnZhbDogdW5kZWZpbmVkLAogICAgICB0aW1lc2VyaWVzOiBuZXcgTWFwKCksCiAgICAgIHNlbGVjdGVkTGFiZWw6ICcnLAogICAgICBsb3dlckNvbmZpZGVuY2U6IGZhbHNlLAogICAgICBsb3dlckNvbmZpZGVuY2VNZXNzYWdlOiAnVHJ5IGxvd2VyaW5nIGNvbmZpZGVuY2UgdGhyZXNob2xkJywKICAgIH0KICB9LAogIGNvbXB1dGVkOiB7CiAgICAuLi5tYXBTdGF0ZShbJ3BsYXllciddKSwKICAgIHNvcnRlZF91bmlxdWVfbGFiZWxzKCkgewogICAgICAvLyBUaGlzIGZ1bmN0aW9uIHNvcnRzIGFuZCBjb3VudHMgdW5pcXVlIGxhYmVscyBmb3IgbW91c2Ugb3ZlciBldmVudHMgb24gbGFiZWwgYnV0dG9ucwogICAgICBjb25zdCBlc19kYXRhID0gdGhpcy5lbGFzdGljc2VhcmNoX2RhdGE7CiAgICAgIGNvbnN0IHVuaXF1ZV9sYWJlbHMgPSBuZXcgTWFwKCk7CiAgICAgIC8vIHNvcnQgYW5kIGNvdW50IHVuaXF1ZSBsYWJlbHMgZm9yIGxhYmVsIG1vdXNlIG92ZXIgZXZlbnRzCiAgICAgIGVzX2RhdGEuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7CiAgICAgICAgdW5pcXVlX2xhYmVscy5zZXQocmVjb3JkLk5hbWUsIHVuaXF1ZV9sYWJlbHMuZ2V0KHJlY29yZC5OYW1lKSA/IHVuaXF1ZV9sYWJlbHMuZ2V0KHJlY29yZC5OYW1lKSArIDEgOiAxKTsKICAgICAgICBpZiAocmVjb3JkLkluc3RhbmNlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAvLyBTYXZlIHRoaXMgbGFiZWwgbmFtZSB0byBhIGxpc3Qgb2YgbGFiZWxzIHRoYXQgaGF2ZSBib3VuZGluZyBib3hlcwogICAgICAgICAgdGhpcy5zYXZlQm94ZWRMYWJlbChyZWNvcmQuTmFtZSkKICAgICAgICB9CiAgICAgIH0uYmluZCh0aGlzKSk7CiAgICAgIGNvbnN0IHNvcnRlZF91bmlxdWVfbGFiZWxzID0gbmV3IE1hcChbLi4udW5pcXVlX2xhYmVscy5lbnRyaWVzKCldLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pKTsKICAgICAgLy8gSWYgRWxhc3RpY3NlYXJjaCByZXR1cm5lZCB1bmRlZmluZWQgbGFiZWxzIHRoZW4gZGVsZXRlIHRoZW06CiAgICAgIHNvcnRlZF91bmlxdWVfbGFiZWxzLmRlbGV0ZSh1bmRlZmluZWQpOwogICAgICB0aGlzLmNvdW50TGFiZWxzKHNvcnRlZF91bmlxdWVfbGFiZWxzLnNpemUsIGVzX2RhdGEubGVuZ3RoKTsKICAgICAgcmV0dXJuIHNvcnRlZF91bmlxdWVfbGFiZWxzCiAgICB9LAogIH0sCiAgd2F0Y2g6IHsKICAgIC8vIFRoZXNlIHdhdGNoZXMgdXBkYXRlIHRoZSBsaW5lIGNoYXJ0CiAgICBzZWxlY3RlZExhYmVsOiBmdW5jdGlvbigpIHsKICAgICAgdGhpcy5jaGFydERhdGEoKTsKICAgIH0sCiAgICBlbGFzdGljc2VhcmNoX2RhdGE6IGZ1bmN0aW9uKCkgewogICAgICB0aGlzLmNoYXJ0RGF0YSgpOwogICAgfSwKICB9LAogIGRlYWN0aXZhdGVkOiBmdW5jdGlvbiAoKSB7CiAgICBjb25zb2xlLmxvZygnZGVhY3RpdmF0ZWQgY29tcG9uZW50OicsIHRoaXMub3BlcmF0b3IpOwogICAgdGhpcy5ib3hlc19hdmFpbGFibGUgPSBbXTsKICAgIHRoaXMuc2VsZWN0ZWRMYWJlbCA9ICcnOwogICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbnZhc1JlZnJlc2hJbnRlcnZhbCk7CiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7CiAgICBsZXQgY3R4OwogICAgaWYgKGNhbnZhcykgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7CiAgICBpZiAoY3R4KSBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7CiAgfSwKICBhY3RpdmF0ZWQ6IGZ1bmN0aW9uICgpIHsKICAgIGNvbnNvbGUubG9nKCdhY3RpdmF0ZWQgY29tcG9uZW50OicsIHRoaXMub3BlcmF0b3IpCiAgICB0aGlzLmZldGNoQXNzZXREYXRhKCk7CiAgfSwKICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiAoKSB7CiAgICB0aGlzLmhpZ2hfY29uZmlkZW5jZV9kYXRhID0gW107CiAgICB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YSA9IFtdOwogICAgdGhpcy5jb3VudF9kaXN0aW5jdF9sYWJlbHMgPSAwOwogICAgdGhpcy5jb3VudF9sYWJlbHMgPSAwOwogICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbnZhc1JlZnJlc2hJbnRlcnZhbCk7CiAgfSwKICBtZXRob2RzOiB7CiAgICBzYXZlQm94ZWRMYWJlbChsYWJlbF9uYW1lKXsKICAgICAgaWYgKCF0aGlzLmJveGVzX2F2YWlsYWJsZS5pbmNsdWRlcyhsYWJlbF9uYW1lKSkgewogICAgICAgIHRoaXMuYm94ZXNfYXZhaWxhYmxlLnB1c2gobGFiZWxfbmFtZSk7CiAgICAgIH0KICAgIH0sCiAgICBjb3VudExhYmVscyh1bmlxdWVfY291bnQsIHRvdGFsX2NvdW50KSB7CiAgICAgIHRoaXMuY291bnRfZGlzdGluY3RfbGFiZWxzID0gdW5pcXVlX2NvdW50OwogICAgICB0aGlzLmNvdW50X2xhYmVscyA9IHRvdGFsX2NvdW50OwogICAgfSwKICAgIHNhdmVGaWxlKCkgewogICAgICBjb25zdCBlbGFzdGljc2VhcmNoX2RhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YSk7CiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbZWxhc3RpY3NlYXJjaF9kYXRhXSwge3R5cGU6ICd0ZXh0L3BsYWluJ30pOwogICAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyksCiAgICAgICAgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTsKICAgICAgYS5kb3dubG9hZCA9ICJkYXRhLmpzb24iOwogICAgICBhLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTsKICAgICAgYS5kYXRhc2V0LmRvd25sb2FkdXJsID0gWyd0ZXh0L2pzb24nLCBhLmRvd25sb2FkLCBhLmhyZWZdLmpvaW4oJzonKTsKICAgICAgZS5pbml0RXZlbnQoJ2NsaWNrJywgdHJ1ZSwgZmFsc2UsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpOwogICAgICBhLmRpc3BhdGNoRXZlbnQoZSk7CiAgICB9LAogICAgdXBkYXRlQ29uZmlkZW5jZSAoZXZlbnQpIHsKICAgICAgdGhpcy5pc0J1c3kgPSB0cnVlOwogICAgICB0aGlzLkNvbmZpZGVuY2UgPSBldmVudC50YXJnZXQudmFsdWU7CiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZSA9PT0gInZpZGVvIikgewogICAgICAgIC8vIHJlZHJhdyBtYXJrZXJzIG9uIHZpZGVvIHRpbWVsaW5lCiAgICAgICAgdGhpcy5wbGF5ZXIubWFya2Vycy5yZW1vdmVBbGwoKTsKICAgICAgfQogICAgICB0aGlzLmZldGNoQXNzZXREYXRhKCkKICAgIH0sCiAgICAvLyB1cGRhdGVNYXJrZXJzIHVwZGF0ZXMgbWFya2VycyBpbiB0aGUgdmlkZW8gcGxheWVyIGFuZCBpcyBjYWxsZWQgd2hlbiBzb21lb25lIGNsaWNrcyBvbiBhIGxhYmVsIGJ1dHRvbgogICAgdXBkYXRlTWFya2VycyAobGFiZWwpIHsKICAgICAgLy8gY2xlYXIgY2FudmFzIGZvciByZWRyYXdpbmcKICAgICAgdGhpcy5ib3hlc19hdmFpbGFibGUgPSBbXTsKICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbnZhc1JlZnJlc2hJbnRlcnZhbCk7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTsKICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7CiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsKICAgICAgY3R4LnN0cm9rZVN0eWxlID0gInJlZCI7CiAgICAgIGN0eC5mb250ID0gIjE1cHggQXJpYWwiOwogICAgICBjdHgudGV4dEFsaWduID0gImNlbnRlciI7CiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAibWlkZGxlIjsKICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZWQiOwogICAgICBpZiAodGhpcy5zZWxlY3RlZExhYmVsID09PSBsYWJlbCkgewogICAgICAgIC8vIGtlZXAgdGhlIGNhbnZhcyBjbGVhciBjYW52YXMgaWYgdXNlciBjbGlja2VkIHRoZSBsYWJlbCBidXR0b24gYSBzZWNvbmQgY29uc2VjdXRpdmUgdGltZQogICAgICAgIHRoaXMuc2VsZWN0ZWRMYWJlbCA9ICIiOwogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIHRoaXMuc2VsZWN0ZWRMYWJlbCA9IGxhYmVsOyAgICAgICAgLy8gaW5pdGlhbGl6ZSBsaXN0cyBvZiBib3hlcyBhbmQgbWFya2VycyB0byBiZSBkcmF3bgogICAgICBjb25zdCBib3hNYXAgPSBuZXcgTWFwKCk7CiAgICAgIGNvbnN0IG1hcmtlcnMgPSBbXTsKICAgICAgY29uc3QgZXNfZGF0YSA9IHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhOwogICAgICBlc19kYXRhLmZvckVhY2goIGZ1bmN0aW9uKHJlY29yZCkgewogICAgICAgIGlmIChyZWNvcmQuTmFtZSA9PT0gbGFiZWwpIHsKICAgICAgICAgIC8vIFNhdmUgbGFiZWwgbmFtZSBvdmVybGF5aW5nIG9uIHZpZGVvIHRpbWVsaW5lCiAgICAgICAgICBtYXJrZXJzLnB1c2goeyd0aW1lJzogcmVjb3JkLlRpbWVzdGFtcC8xMDAwLCAndGV4dCc6IHJlY29yZC5OYW1lLCAnb3ZlcmxheVRleHQnOiByZWNvcmQuTmFtZX0pOwogICAgICAgICAgLy8gU2F2ZSBib3VuZGluZyBib3ggaW5mbyBpZiBpdCBleGlzdHMKICAgICAgICAgIGlmIChyZWNvcmQuSW5zdGFuY2VzLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCB0aGUgYm94ZXMgcmVjb3JkZWQgZm9yIHRoZSBsYWJlbCBhdCB0aGlzIHRpbWUKICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlY29yZC5JbnN0YW5jZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICBjb25zdCBpdGVtID0gcmVjb3JkLkluc3RhbmNlc1tpXTsKICAgICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIGltYWdlIHByb2Nlc3NpbmcgdG8gYSBzZXBhcmF0ZSBjb21wb25lbnQKICAgICAgICAgICAgICBpZiAodGhpcy5tZWRpYVR5cGUgPT09ICJpbWFnZSIpIHsKICAgICAgICAgICAgICAgIC8vIHVzZSB0aW1lc3RhbXAgdG8gaW5kZXggYm94ZXMgaW4gdGhlIGJveE1hcCBjb2xsZWN0aW9uCiAgICAgICAgICAgICAgICBjb25zdCBib3hpbmZvID0gewogICAgICAgICAgICAgICAgICAnaW5zdGFuY2UnOiBpLAogICAgICAgICAgICAgICAgICAnbmFtZSc6IHJlY29yZC5OYW1lLAogICAgICAgICAgICAgICAgICAnY29uZmlkZW5jZSc6IChyZWNvcmQuQ29uZmlkZW5jZSAqIDEpLnRvRml4ZWQoMiksCiAgICAgICAgICAgICAgICAgICd4JzogaXRlbS5Cb3VuZGluZ0JveC5MZWZ0ICogY2FudmFzLndpZHRoLAogICAgICAgICAgICAgICAgICAneSc6IGl0ZW0uQm91bmRpbmdCb3guVG9wICogY2FudmFzLmhlaWdodCwKICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogaXRlbS5Cb3VuZGluZ0JveC5XaWR0aCAqIGNhbnZhcy53aWR0aCwKICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6IGl0ZW0uQm91bmRpbmdCb3guSGVpZ2h0ICogY2FudmFzLmhlaWdodAogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIGJveE1hcC5zZXQoaSwgW2JveGluZm9dKQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAvLyBVc2UgdGltZSByZXNvbHV0aW9uIG9mIDAuMSBzZWNvbmQKICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGgucm91bmQocmVjb3JkLlRpbWVzdGFtcC8xMDApOwogICAgICAgICAgICAgICAgY29uc3QgYm94aW5mbyA9IHsnaW5zdGFuY2UnOmksICd0aW1lc3RhbXAnOk1hdGguY2VpbChyZWNvcmQuVGltZXN0YW1wLzEwMCksICduYW1lJzpyZWNvcmQuTmFtZSwgJ2NvbmZpZGVuY2UnOihyZWNvcmQuQ29uZmlkZW5jZSAqIDEpLnRvRml4ZWQoMiksICd4JzppdGVtLkJvdW5kaW5nQm94LkxlZnQqY2FudmFzLndpZHRoLCAneSc6aXRlbS5Cb3VuZGluZ0JveC5Ub3AqY2FudmFzLmhlaWdodCwgJ3dpZHRoJzppdGVtLkJvdW5kaW5nQm94LldpZHRoKmNhbnZhcy53aWR0aCwgJ2hlaWdodCc6aXRlbS5Cb3VuZGluZ0JveC5IZWlnaHQqY2FudmFzLmhlaWdodH07CiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoaXMgaW5zdGFuY2UgYXQgdGhpcwogICAgICAgICAgICAgICAgLy8gdGltZXN0YW1wLCB0aGVuIHNhdmUgdGhlbSB0b2dldGhlciBpbiBhbiBhcnJheS4KICAgICAgICAgICAgICAgIGlmIChib3hNYXAuaGFzKHRpbWVzdGFtcCkpIHsKICAgICAgICAgICAgICAgICAgYm94TWFwLmdldCh0aW1lc3RhbXApLnB1c2goYm94aW5mbykKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGJveE1hcC5zZXQodGltZXN0YW1wLCBbYm94aW5mb10pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LmJpbmQodGhpcykpOwogICAgICBpZiAoYm94TWFwLnNpemUgPiAwKSB7CiAgICAgICAgdGhpcy5kcmF3Qm94ZXMoYm94TWFwKTsKICAgICAgfQogICAgICAvLyBUT0RPOiBtb3ZlIGltYWdlIHByb2Nlc3NpbmcgdG8gYSBzZXBhcmF0ZSBjb21wb25lbnQKICAgICAgaWYgKHRoaXMubWVkaWFUeXBlID09PSAidmlkZW8iKSB7CiAgICAgICAgLy8gcmVkcmF3IG1hcmtlcnMgb24gdmlkZW8gdGltZWxpbmUKICAgICAgICB0aGlzLnBsYXllci5tYXJrZXJzLnJlbW92ZUFsbCgpOwogICAgICAgIHRoaXMucGxheWVyLm1hcmtlcnMuYWRkKG1hcmtlcnMpOwogICAgICB9CiAgICB9LAogICAgYXN5bmMgZmV0Y2hBc3NldERhdGEgKCkgewogICAgICAgIGxldCBxdWVyeSA9ICdBc3NldElkOicrdGhpcy4kcm91dGUucGFyYW1zLmFzc2V0X2lkKycgQ29uZmlkZW5jZTo+Jyt0aGlzLkNvbmZpZGVuY2UrJyBPcGVyYXRvcjonK3RoaXMub3BlcmF0b3I7CiAgICAgICAgbGV0IGFwaU5hbWUgPSAnY29udGVudEFuYWx5c2lzRWxhc3RpY3NlYXJjaCc7CiAgICAgICAgbGV0IHBhdGggPSAnL19zZWFyY2gnOwogICAgICAgIGxldCBhcGlQYXJhbXMgPSB7CiAgICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30sCiAgICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnM6IHsncSc6IHF1ZXJ5LCAnZGVmYXVsdF9vcGVyYXRvcic6ICdBTkQnLCAnc2l6ZSc6IDEwMDAwfQogICAgICAgIH07CiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4kQW1wbGlmeS5BUEkuZ2V0KGFwaU5hbWUsIHBhdGgsIGFwaVBhcmFtcyk7CiAgICAgICAgaWYgKCFyZXNwb25zZSkgewogICAgICAgICAgdGhpcy5zaG93RWxhc3RpY1NlYXJjaEFsZXJ0ID0gdHJ1ZQogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgIGxldCBlc19kYXRhID0gW107CiAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2U7CiAgICAgICAgICBsZXQgZGF0YSA9IHJlc3VsdC5oaXRzLmhpdHM7CiAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDAgJiYgdGhpcy5Db25maWRlbmNlID4gNTUpIHsKICAgICAgICAgICAgICB0aGlzLmxvd2VyQ29uZmlkZW5jZSA9IHRydWU7CiAgICAgICAgICAgICAgdGhpcy5sb3dlckNvbmZpZGVuY2VNZXNzYWdlID0gJ1RyeSBsb3dlcmluZyBjb25maWRlbmNlIHRocmVzaG9sZCcKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgewogICAgICAgICAgICB0aGlzLmxvd2VyQ29uZmlkZW5jZSA9IGZhbHNlOwogICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICAgIGVzX2RhdGEucHVzaChkYXRhW2ldLl9zb3VyY2UpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlc19kYXRhKSk7CiAgICAgICAgICB0aGlzLmlzQnVzeSA9IGZhbHNlCiAgICAgIH0KICAgIH0sCiAgICBkcmF3Qm94ZXM6IGZ1bmN0aW9uKGJveE1hcCkgewogICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7CiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgICAvLyBUT0RPOiBtb3ZlIGltYWdlIHByb2Nlc3NpbmcgdG8gYSBzZXBhcmF0ZSBjb21wb25lbnQKICAgICAgaWYgKHRoaXMubWVkaWFUeXBlID09PSAiaW1hZ2UiKSB7CiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpOwogICAgICAgIGN0eC5iZWdpblBhdGgoKTsKICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAicmVkIjsKICAgICAgICBjdHguZm9udCA9ICIxNXB4IEFyaWFsIjsKICAgICAgICBjdHgudGV4dEFsaWduID0gImNlbnRlciI7CiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICJtaWRkbGUiOwogICAgICAgIGN0eC5maWxsU3R5bGUgPSAicmVkIjsKICAgICAgICAvLyBGb3IgZWFjaCBib3ggaW5zdGFuY2UuLi4KICAgICAgICBib3hNYXAuZm9yRWFjaCggaSA9PiB7CiAgICAgICAgICBjb25zdCBkcmF3TWUgPSBpWzBdOwogICAgICAgICAgaWYgKGRyYXdNZSkgewogICAgICAgICAgICBjdHgucmVjdChkcmF3TWUueCwgZHJhd01lLnksIGRyYXdNZS53aWR0aCwgZHJhd01lLmhlaWdodCk7CiAgICAgICAgICAgIC8vIERyYXcgb2JqZWN0IG5hbWUgYW5kIGNvbmZpZGVuY2Ugc2NvcmUKICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGRyYXdNZS5uYW1lICsgIiAoIiArIGRyYXdNZS5jb25maWRlbmNlICsgIiUpIiwgKGRyYXdNZS54ICsgZHJhd01lLndpZHRoIC8gMiksIGRyYXdNZS55IC0gMTApOwogICAgICAgICAgICBjdHguc3Ryb2tlKCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgLy8gbm93IHJldHVybiBzbyB3ZSBhdm9pZCByZW5kZXJpbmcgYW55IG9mIHRoZSB2aWRlbyByZWxhdGVkIGNvbXBvbmVudHMgYmVsb3cKICAgICAgICByZXR1cm4KICAgICAgfQogICAgICAvLyBJZiB1c2VyIGp1c3QgY2xpY2tlZCBhIG5ldyBsYWJlbC4uLgogICAgICBpZiAodGhpcy5jYW52YXNSZWZyZXNoSW50ZXJ2YWwgIT09IHVuZGVmaW5lZCkgewogICAgICAgIC8vIC4uLnRoZW4gcmVzZXQgdGhlIG9sZCBjYW52YXMgcmVmcmVzaCBpbnRlcnZhbC4KICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2FudmFzUmVmcmVzaEludGVydmFsKQogICAgICB9CiAgICAgIC8vIExvb2sgZm9yIGFuZCBkcmF3IGJvdW5kaW5nIGJveGVzIGV2ZXJ5IDEwMG1zCiAgICAgIGNvbnN0IGludGVydmFsX21zID0gMTAwOwogICAgICBjb25zdCBlcmFzZV9vbl9pdGVyYXRpb24gPSAyOwogICAgICBsZXQgaSA9IDA7CiAgICAgIHRoaXMuY2FudmFzUmVmcmVzaEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgewogICAgICAgIGkrKzsKICAgICAgICAvLyBlcmFzZSBvbGQgYm91bmRpbmcgYm94ZXMKICAgICAgICBpZiAoIXRoaXMucGxheWVyLnBhdXNlZCgpICYmIGkgJSBlcmFzZV9vbl9pdGVyYXRpb24gPT09IDApIHsKICAgICAgICAgIGk9MDsKICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsKICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTsKICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICJyZWQiOwogICAgICAgICAgY3R4LmZvbnQgPSAiMTVweCBBcmlhbCI7CiAgICAgICAgICBjdHgudGV4dEFsaWduID0gImNlbnRlciI7CiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gIm1pZGRsZSI7CiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gInJlZCI7CiAgICAgICAgfQogICAgICAgIC8vIEdldCBjdXJyZW50IHBsYXllciB0aW1lc3RhbXAgdG8gdGhlIG5lYXJlc3QgMS8xMHRoIHNlY29uZAogICAgICAgIGNvbnN0IHBsYXllcl90aW1lc3RhbXAgPSBNYXRoLnJvdW5kKHRoaXMucGxheWVyLmN1cnJlbnRUaW1lKCkqMTAuMCk7CiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGJveCBmb3IgdGhlIHBsYXllcidzIHRpbWVzdGFtcC4uLgogICAgICAgIGlmIChib3hNYXAuaGFzKHBsYXllcl90aW1lc3RhbXApKSB7CiAgICAgICAgICBpPTA7CiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7CiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAicmVkIjsKICAgICAgICAgIGN0eC5mb250ID0gIjE1cHggQXJpYWwiOwogICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICJjZW50ZXIiOwogICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICJtaWRkbGUiOwogICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZWQiOwogICAgICAgICAgLy8gLi4udGhlbiBnZXQgYSBsaXN0IG9mIGJveCBpbnN0YW5jZXMKICAgICAgICAgIGNvbnN0IGluc3RhbmNlX2xpc3QgPSAoYm94TWFwLmdldChwbGF5ZXJfdGltZXN0YW1wKSkubWFwKCBpdGVtID0+IGl0ZW0uaW5zdGFuY2UpLmZpbHRlcigodiwgaSwgYSkgPT4gYS5pbmRleE9mKHYpID09PSBpKTsKICAgICAgICAgIC8vIEZvciBlYWNoIGJveCBpbnN0YW5jZS4uLgogICAgICAgICAgaW5zdGFuY2VfbGlzdC5mb3JFYWNoKCBpID0+IHsKICAgICAgICAgICAgLy8gLi4uZ2V0IGFsbCBvZiB0aGUgYm94ZXMgYmVsb25naW5nIHRvIHRoaXMgaW5zdGFuY2UKICAgICAgICAgICAgLy8gYXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wLgogICAgICAgICAgICBjb25zdCBib3hlcyA9IGJveE1hcC5nZXQocGxheWVyX3RpbWVzdGFtcCkuZmlsdGVyKGJveCA9PiBib3guaW5zdGFuY2UgPT09IGkpOwogICAgICAgICAgICBib3hlcy5mb3JFYWNoIChkcmF3TWUgPT4gewogICAgICAgICAgICAgIGlmIChkcmF3TWUpIHsKICAgICAgICAgICAgICAgIGN0eC5yZWN0KGRyYXdNZS54LCBkcmF3TWUueSwgZHJhd01lLndpZHRoLCBkcmF3TWUuaGVpZ2h0KTsKICAgICAgICAgICAgICAgIC8vIERyYXcgb2JqZWN0IG5hbWUgYW5kIGNvbmZpZGVuY2Ugc2NvcmUKICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChkcmF3TWUubmFtZSArICIgKCIgKyBkcmF3TWUuY29uZmlkZW5jZSArICIlKSIsIChkcmF3TWUueCArIGRyYXdNZS53aWR0aCAvIDIpLCBkcmF3TWUueSAtIDEwKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pCiAgICAgICAgICB9KTsKICAgICAgICAgIGN0eC5zdHJva2UoKTsKICAgICAgICB9CiAgICAgIH0uYmluZCh0aGlzKSwgaW50ZXJ2YWxfbXMpOwogICAgfSwKICAgIGNoYXJ0RGF0YSgpIHsKICAgICAgbGV0IHRpbWVzZXJpZXMgPSBuZXcgTWFwKCk7CiAgICAgIGZ1bmN0aW9uIHNhdmVUaW1lc3RhbXAgKG1pbGxpc2Vjb25kKSB7CiAgICAgICAgaWYgKHRpbWVzZXJpZXMuaGFzKG1pbGxpc2Vjb25kKSkgewogICAgICAgICAgdGltZXNlcmllcy5zZXQobWlsbGlzZWNvbmQsIHsieCI6IG1pbGxpc2Vjb25kLCAieSI6IHRpbWVzZXJpZXMuZ2V0KG1pbGxpc2Vjb25kKS55ICsgMX0pCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRpbWVzZXJpZXMuc2V0KG1pbGxpc2Vjb25kLCB7IngiOiBtaWxsaXNlY29uZCwgInkiOjF9KQogICAgICAgIH0KICAgICAgfQogICAgICBjb25zdCBlc19kYXRhID0gdGhpcy5lbGFzdGljc2VhcmNoX2RhdGE7CiAgICAgIGVzX2RhdGEuZm9yRWFjaCggZnVuY3Rpb24ocmVjb3JkKSB7CiAgICAgICAgLy8gRGVmaW5lIHRpbWVzdGFtcCB3aXRoIG1pbGxpc2Vjb25kIHJlc29sdXRpb24KICAgICAgICBjb25zdCBtaWxsaXNlY29uZCA9IE1hdGgucm91bmQocmVjb3JkLlRpbWVzdGFtcCk7CiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRMYWJlbCkgewogICAgICAgICAgLy8gSWYgbGFiZWwgaXMgZGVmaW5lZCwgdGhlbiBlbnVtZXJhdGUgdGltZXN0YW1wcyBmb3IgdGhhdCBsYWJlbAogICAgICAgICAgaWYgKHJlY29yZC5OYW1lID09PSB0aGlzLnNlbGVjdGVkTGFiZWwpIHsKICAgICAgICAgICAgaWYgKHJlY29yZC5JbnN0YW5jZXMubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb3JkLkluc3RhbmNlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgc2F2ZVRpbWVzdGFtcChtaWxsaXNlY29uZCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHNhdmVUaW1lc3RhbXAobWlsbGlzZWNvbmQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIE5vIGxhYmVsIGhhcyBiZWVuIHNlbGVjdGVkLCBzbyBlbnVtZXJhdGUgdGltZXN0YW1wcyBmb3IgYWxsIGxhYmVsIG5hbWVzLgogICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGJvdW5kaW5nIGJveGVzIGlmIHByZXNlbnQuCiAgICAgICAgICBpZiAocmVjb3JkLkluc3RhbmNlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb3JkLkluc3RhbmNlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIHNhdmVUaW1lc3RhbXAobWlsbGlzZWNvbmQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzYXZlVGltZXN0YW1wKG1pbGxpc2Vjb25kKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0uYmluZCh0aGlzKSk7CiAgICAgIC8vc29ydCB0aGUgdGltZXNlcmllcyBtYXAgYnkgaXRzIG1pbGxpc2Vjb25kIGtleQogICAgICBjb25zdCBvcmRlcmVkX3RpbWVzZXJpZXMgPSBuZXcgTWFwKFsuLi50aW1lc2VyaWVzLmVudHJpZXMoKV0uc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSkpOwogICAgICBjb25zdCBjaGFydFR1cGxlcyA9IEFycmF5LmZyb20ob3JkZXJlZF90aW1lc2VyaWVzLnZhbHVlcygpKTsKICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCd1cGRhdGVUaW1lc2VyaWVzJywgY2hhcnRUdXBsZXMpOwogICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3VwZGF0ZVNlbGVjdGVkTGFiZWwnLCB0aGlzLnNlbGVjdGVkTGFiZWwpOwogICAgfSwKICB9Cn0K"},{"version":3,"sources":["LabelObjects.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"LabelObjects.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <b-container fluid>\n    <b-col>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          Confidence Threshold<br>\n          <input\n            type=\"range\"\n            value=\"90\"\n            min=\"55\"\n            max=\"99\"\n            step=\"1\"\n            @click=\"updateConfidence\"\n          >\n          {{ Confidence }}%<br>\n        </div>\n      </b-row>\n      <div v-if=\"lowerConfidence === true\">\n        {{ lowerConfidenceMessage }}\n      </div>\n      <div\n        v-if=\"isBusy\"\n        class=\"wrapper\"\n      >\n        <Loading />\n      </div>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          <br>\n          <template v-for=\"label in sorted_unique_labels\">\n            <template v-if=\"boxes_available.includes(label[0])\">\n              <!-- Show darker button outline if boxes are available for the label -->\n              <b-button\n                v-b-tooltip.hover\n                variant=\"outline-dark\"\n                :title=\"label[1]\"\n                size=\"sm\"\n                pill\n                @click=\"updateMarkers(label[0])\"\n              >\n                {{ label[0]+\"*\" }}\n              </b-button> &nbsp;\n            </template>\n            <template v-else>\n              <b-button\n                v-b-tooltip.hover\n                variant=\"outline-secondary\"\n                :title=\"label[1]\"\n                size=\"sm\"\n                pill\n                @click=\"updateMarkers(label[0])\"\n              >\n                {{ label[0] }}\n              </b-button> &nbsp;\n            </template>\n          </template>\n        </div>\n      </b-row>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div\n          v-if=\"isBusy === false\"\n          class=\"wrapper\"\n        >\n          <p class=\"text-muted\">\n            ({{ count_labels }} identified objects, {{ count_distinct_labels }} unique)\n          </p>\n          <hr>\n          <p class=\"text-muted\">\n            * Indicates bounding boxes are available.\n          </p>\n        </div>\n      </b-row>\n    </b-col>\n    <b-button\n      type=\"button\"\n      @click=\"saveFile()\"\n    >\n      Download Data\n    </b-button>\n  </b-container>\n</template>\n\n<script>\n  import Loading from '@/components/Loading.vue'\n  import { mapState } from 'vuex'\n  export default {\n    name: \"LabelObjects\",\n    components: {\n      Loading\n    },\n    props: {\n      mediaType: {\n        type: String,\n        default: \"\"\n      },\n    },\n    data() {\n      return {\n        Confidence: 90,\n        high_confidence_data: [],\n        elasticsearch_data: [],\n        boxes_available: [],\n        count_distinct_labels: 0,\n        count_labels: 0,\n        isBusy: false,\n        operator: 'label_detection',\n        canvasRefreshInterval: undefined,\n        timeseries: new Map(),\n        selectedLabel: '',\n        lowerConfidence: false,\n        lowerConfidenceMessage: 'Try lowering confidence threshold',\n      }\n    },\n    computed: {\n      ...mapState(['player']),\n      sorted_unique_labels() {\n        // This function sorts and counts unique labels for mouse over events on label buttons\n        const es_data = this.elasticsearch_data;\n        const unique_labels = new Map();\n        // sort and count unique labels for label mouse over events\n        es_data.forEach(function (record) {\n          unique_labels.set(record.Name, unique_labels.get(record.Name) ? unique_labels.get(record.Name) + 1 : 1);\n          if (record.Instances.length > 0) {\n            // Save this label name to a list of labels that have bounding boxes\n            this.saveBoxedLabel(record.Name)\n          }\n        }.bind(this));\n        const sorted_unique_labels = new Map([...unique_labels.entries()].slice().sort((a, b) => b[1] - a[1]));\n        // If Elasticsearch returned undefined labels then delete them:\n        sorted_unique_labels.delete(undefined);\n        this.countLabels(sorted_unique_labels.size, es_data.length);\n        return sorted_unique_labels\n      },\n    },\n    watch: {\n      // These watches update the line chart\n      selectedLabel: function() {\n        this.chartData();\n      },\n      elasticsearch_data: function() {\n        this.chartData();\n      },\n    },\n    deactivated: function () {\n      console.log('deactivated component:', this.operator);\n      this.boxes_available = [];\n      this.selectedLabel = '';\n      clearInterval(this.canvasRefreshInterval);\n      const canvas = document.getElementById('canvas');\n      let ctx;\n      if (canvas) ctx = canvas.getContext('2d');\n      if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);\n    },\n    activated: function () {\n      console.log('activated component:', this.operator)\n      this.fetchAssetData();\n    },\n    beforeDestroy: function () {\n      this.high_confidence_data = [];\n      this.elasticsearch_data = [];\n      this.count_distinct_labels = 0;\n      this.count_labels = 0;\n      clearInterval(this.canvasRefreshInterval);\n    },\n    methods: {\n      saveBoxedLabel(label_name){\n        if (!this.boxes_available.includes(label_name)) {\n          this.boxes_available.push(label_name);\n        }\n      },\n      countLabels(unique_count, total_count) {\n        this.count_distinct_labels = unique_count;\n        this.count_labels = total_count;\n      },\n      saveFile() {\n        const elasticsearch_data = JSON.stringify(this.elasticsearch_data);\n        const blob = new Blob([elasticsearch_data], {type: 'text/plain'});\n        const e = document.createEvent('MouseEvents'),\n          a = document.createElement('a');\n        a.download = \"data.json\";\n        a.href = window.URL.createObjectURL(blob);\n        a.dataset.downloadurl = ['text/json', a.download, a.href].join(':');\n        e.initEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n        a.dispatchEvent(e);\n      },\n      updateConfidence (event) {\n        this.isBusy = true;\n        this.Confidence = event.target.value;\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n        }\n        this.fetchAssetData()\n      },\n      // updateMarkers updates markers in the video player and is called when someone clicks on a label button\n      updateMarkers (label) {\n        // clear canvas for redrawing\n        this.boxes_available = [];\n        clearInterval(this.canvasRefreshInterval);\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.strokeStyle = \"red\";\n        ctx.font = \"15px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillStyle = \"red\";\n        if (this.selectedLabel === label) {\n          // keep the canvas clear canvas if user clicked the label button a second consecutive time\n          this.selectedLabel = \"\";\n          return\n        }\n        this.selectedLabel = label;        // initialize lists of boxes and markers to be drawn\n        const boxMap = new Map();\n        const markers = [];\n        const es_data = this.elasticsearch_data;\n        es_data.forEach( function(record) {\n          if (record.Name === label) {\n            // Save label name overlaying on video timeline\n            markers.push({'time': record.Timestamp/1000, 'text': record.Name, 'overlayText': record.Name});\n            // Save bounding box info if it exists\n            if (record.Instances.length > 0) {\n              // Iterate through all the boxes recorded for the label at this time\n              for (let i=0; i<record.Instances.length; i++) {\n                const item = record.Instances[i];\n                // TODO: move image processing to a separate component\n                if (this.mediaType === \"image\") {\n                  // use timestamp to index boxes in the boxMap collection\n                  const boxinfo = {\n                    'instance': i,\n                    'name': record.Name,\n                    'confidence': (record.Confidence * 1).toFixed(2),\n                    'x': item.BoundingBox.Left * canvas.width,\n                    'y': item.BoundingBox.Top * canvas.height,\n                    'width': item.BoundingBox.Width * canvas.width,\n                    'height': item.BoundingBox.Height * canvas.height\n                  };\n                  boxMap.set(i, [boxinfo])\n                } else {\n                  // Use time resolution of 0.1 second\n                  const timestamp = Math.round(record.Timestamp/100);\n                  const boxinfo = {'instance':i, 'timestamp':Math.ceil(record.Timestamp/100), 'name':record.Name, 'confidence':(record.Confidence * 1).toFixed(2), 'x':item.BoundingBox.Left*canvas.width, 'y':item.BoundingBox.Top*canvas.height, 'width':item.BoundingBox.Width*canvas.width, 'height':item.BoundingBox.Height*canvas.height};\n                  // If there are multiple bounding boxes for this instance at this\n                  // timestamp, then save them together in an array.\n                  if (boxMap.has(timestamp)) {\n                    boxMap.get(timestamp).push(boxinfo)\n                  } else {\n                    boxMap.set(timestamp, [boxinfo])\n                  }\n                }\n              }\n            }\n          }\n        }.bind(this));\n        if (boxMap.size > 0) {\n          this.drawBoxes(boxMap);\n        }\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n          this.player.markers.add(markers);\n        }\n      },\n      async fetchAssetData () {\n          let query = 'AssetId:'+this.$route.params.asset_id+' Confidence:>'+this.Confidence+' Operator:'+this.operator;\n          let apiName = 'contentAnalysisElasticsearch';\n          let path = '/_search';\n          let apiParams = {\n            headers: {'Content-Type': 'application/json'},\n            queryStringParameters: {'q': query, 'default_operator': 'AND', 'size': 10000}\n          };\n          let response = await this.$Amplify.API.get(apiName, path, apiParams);\n          if (!response) {\n            this.showElasticSearchAlert = true\n          }\n          else {\n            let es_data = [];\n            let result = await response;\n            let data = result.hits.hits;\n            if (data.length === 0 && this.Confidence > 55) {\n                this.lowerConfidence = true;\n                this.lowerConfidenceMessage = 'Try lowering confidence threshold'\n            }\n            else {\n              this.lowerConfidence = false;\n              for (let i = 0, len = data.length; i < len; i++) {\n                es_data.push(data[i]._source)\n              }\n            }\n            this.elasticsearch_data = JSON.parse(JSON.stringify(es_data));\n            this.isBusy = false\n        }\n      },\n      drawBoxes: function(boxMap) {\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"image\") {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.strokeStyle = \"red\";\n          ctx.font = \"15px Arial\";\n          ctx.textAlign = \"center\";\n          ctx.textBaseline = \"middle\";\n          ctx.fillStyle = \"red\";\n          // For each box instance...\n          boxMap.forEach( i => {\n            const drawMe = i[0];\n            if (drawMe) {\n              ctx.rect(drawMe.x, drawMe.y, drawMe.width, drawMe.height);\n              // Draw object name and confidence score\n              ctx.fillText(drawMe.name + \" (\" + drawMe.confidence + \"%)\", (drawMe.x + drawMe.width / 2), drawMe.y - 10);\n              ctx.stroke();\n            }\n          });\n          // now return so we avoid rendering any of the video related components below\n          return\n        }\n        // If user just clicked a new label...\n        if (this.canvasRefreshInterval !== undefined) {\n          // ...then reset the old canvas refresh interval.\n          clearInterval(this.canvasRefreshInterval)\n        }\n        // Look for and draw bounding boxes every 100ms\n        const interval_ms = 100;\n        const erase_on_iteration = 2;\n        let i = 0;\n        this.canvasRefreshInterval = setInterval(function () {\n          i++;\n          // erase old bounding boxes\n          if (!this.player.paused() && i % erase_on_iteration === 0) {\n            i=0;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.beginPath();\n            ctx.strokeStyle = \"red\";\n            ctx.font = \"15px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = \"red\";\n          }\n          // Get current player timestamp to the nearest 1/10th second\n          const player_timestamp = Math.round(this.player.currentTime()*10.0);\n          // If we have a box for the player's timestamp...\n          if (boxMap.has(player_timestamp)) {\n            i=0;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.beginPath();\n            ctx.strokeStyle = \"red\";\n            ctx.font = \"15px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = \"red\";\n            // ...then get a list of box instances\n            const instance_list = (boxMap.get(player_timestamp)).map( item => item.instance).filter((v, i, a) => a.indexOf(v) === i);\n            // For each box instance...\n            instance_list.forEach( i => {\n              // ...get all of the boxes belonging to this instance\n              // at the current timestamp.\n              const boxes = boxMap.get(player_timestamp).filter(box => box.instance === i);\n              boxes.forEach (drawMe => {\n                if (drawMe) {\n                  ctx.rect(drawMe.x, drawMe.y, drawMe.width, drawMe.height);\n                  // Draw object name and confidence score\n                  ctx.fillText(drawMe.name + \" (\" + drawMe.confidence + \"%)\", (drawMe.x + drawMe.width / 2), drawMe.y - 10);\n                }\n              })\n            });\n            ctx.stroke();\n          }\n        }.bind(this), interval_ms);\n      },\n      chartData() {\n        let timeseries = new Map();\n        function saveTimestamp (millisecond) {\n          if (timeseries.has(millisecond)) {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\": timeseries.get(millisecond).y + 1})\n          } else {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\":1})\n          }\n        }\n        const es_data = this.elasticsearch_data;\n        es_data.forEach( function(record) {\n          // Define timestamp with millisecond resolution\n          const millisecond = Math.round(record.Timestamp);\n          if (this.selectedLabel) {\n            // If label is defined, then enumerate timestamps for that label\n            if (record.Name === this.selectedLabel) {\n              if (record.Instances.length > 0) {\n                for (let i = 0; i < record.Instances.length; i++) {\n                  saveTimestamp(millisecond);\n                }\n              } else {\n                saveTimestamp(millisecond);\n              }\n            }\n          } else {\n            // No label has been selected, so enumerate timestamps for all label names.\n            // Iterate through bounding boxes if present.\n            if (record.Instances.length > 0) {\n              for (let i = 0; i < record.Instances.length; i++) {\n                saveTimestamp(millisecond);\n              }\n            } else {\n              saveTimestamp(millisecond);\n            }\n          }\n        }.bind(this));\n        //sort the timeseries map by its millisecond key\n        const ordered_timeseries = new Map([...timeseries.entries()].slice().sort((a, b) => a[0] - b[0]));\n        const chartTuples = Array.from(ordered_timeseries.values());\n        this.$store.commit('updateTimeseries', chartTuples);\n        this.$store.commit('updateSelectedLabel', this.selectedLabel);\n      },\n    }\n  }\n</script>\n"]}]}